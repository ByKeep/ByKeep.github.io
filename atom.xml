<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DoCode</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-17T16:35:28.059Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>DoCode</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java基础篇-网络编程</title>
    <link href="http://yoursite.com/2019/09/18/Java%E5%9F%BA%E7%A1%80%E7%AF%87-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/09/18/Java基础篇-网络编程/</id>
    <published>2019-09-17T16:35:28.030Z</published>
    <updated>2019-09-17T16:35:28.059Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>如何建立在不同机器中的两个软件的通信？</p><p>(1)找到对方机器的IP地址</p><p>(2)通过对应用程序的数字标识，使得数据发送到对应的应用程序上。为了方便称呼这些数字标识，这些标识被称为端口。这些端口并非物理端口，只是逻辑端口</p><p>(3)定义通信规则（协议），才能双方通信。国际组织定义了通用TCP/IP协议</p><p><img src="/.com//桌面\SpringBootWeb\Snipaste_2019-09-17_20-28-11.png" alt="Snipaste_2019-09-17_20-28-11"></p><h1 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h1><h2 id="通信原理"><a href="#通信原理" class="headerlink" title="通信原理"></a>通信原理</h2><p>数据传输的过程中需要对数据进行加入各类不同协议信息封装后发出，在接收方接收到数据后对数据进行拆包操作获取数据信息。</p><h2 id="网络模型-1"><a href="#网络模型-1" class="headerlink" title="网络模型"></a>网络模型</h2><p>为了划分网络在传输过程中每个层次对应的功能不同，而产生了网络模型。</p><p>（1）OSI模型</p><p>在数据传输的过程中，发送端将数据从应用层到物理层从上到下对数据进行打包封装。接收端对接收到的数据进行拆包操作，流程是从物理层到应用层，</p><p>（2）TCP/IP参考模型</p><p>在经过漫长的演变和发展，TCP/IP层将层次数量减少，将原来的OSI参考模型的几个层次合并为一个层次。</p><p><img src="/.com//桌面\SpringBootWeb\Snipaste_2019-09-17_22-22-41.png" alt="Snipaste_2019-09-17_22-22-41"></p><h1 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>IP地址用于标识网络中的设备名。但是IP地址不便记忆，在本机的回环地址中可以使用localhost代替127.0.0.1；在网络中使用主机名代替IP地址。如<a href="http://www.baidu.com中baidu就是主机名" target="_blank" rel="noopener">www.baidu.com中baidu就是主机名</a></p><h2 id="java获取本机IP地址与名称"><a href="#java获取本机IP地址与名称" class="headerlink" title="java获取本机IP地址与名称"></a>java获取本机IP地址与名称</h2><p>（1）导入net包</p><p>（2）使用包中的InetAddress类中的静态方法getLocalHost()，获取IP地址对象InetAddress;</p><p>（3）调用对象方法获取本机IP地址与名称</p><p>（4）抛出异常</p><p><img src="/.com//桌面\SpringBootWeb\Snipaste_2019-09-17_22-58-56.png" alt="Snipaste_2019-09-17_22-58-56"></p><h1 id="TCP和UDP"><a href="#TCP和UDP" class="headerlink" title="TCP和UDP"></a>TCP和UDP</h1><p>TCP和UDP是常用的两种通信协议，建立两端设备的通信。</p><h2 id="UDP和TCP特点"><a href="#UDP和TCP特点" class="headerlink" title="UDP和TCP特点"></a>UDP和TCP特点</h2><p>UDP</p><p>（1）将数据及源和目的封装成数据包中，不需要建立连接</p><p>（2）每个数据包的大小限制在64K内</p><p>（3）因为是无连接所示是不可靠协议（容易丢包）</p><p>（4）不需要建立连接、速度快</p><p><strong>常见应用：即时通信、网络视频会议、桌面共享等追求速度的场合</strong></p><p>TCP</p><p>（1）建立连接，形成传输数据的通道</p><p>（2）在连接中进行大数据量传输</p><p>（3）通过三次握手完成连接，是可靠协议</p><p>​           三次握手：发出第一次请求（一次），目标机应答（二次），主机应答目标机（三次）</p><p>（4）必须建立连接，效率会稍低</p><h1 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h1><p>其实我们说的网络编程其实指的就是Socket编程，Socket是为网络服务提供的一种机制。相当于一个端点，依靠这个端点实现通信双方的通信通路</p><p>（1）通信的两端都必须有Socket</p><p>（2）网络通信其实就是Socket间的通信</p><p>（3）数据在两个Socket间通过IO进行传输</p><h1 id="UDP通行"><a href="#UDP通行" class="headerlink" title="UDP通行"></a>UDP通行</h1><h2 id="UDP发送端"><a href="#UDP发送端" class="headerlink" title="UDP发送端"></a>UDP发送端</h2><p>虽然已经有了Socket通信端点，但是针对不同的协议，建立通信短点的方式也是不同的。以下介绍UDP传输的服务发送端是如何建立的：</p><p>步骤：</p><p>（1）建立udpsocket服务</p><p>（2）提供数据，并将数据封装到数据包中</p><p>（3）通过Socket服务的发送功能，将数据包发出去</p><p>（4）关闭资源</p><p><img src="/.com//桌面\SpringBootWeb\Snipaste_2019-09-18_00-08-08.png" alt="Snipaste_2019-09-18_00-08-08"></p><h2 id="UDP接收端"><a href="#UDP接收端" class="headerlink" title="UDP接收端"></a>UDP接收端</h2><p>步骤：</p><p>（1）定义udpsocket服务，监听一个端口</p><p>（2）定义一个空的数据包，用来存储接收到的数据。因为数据包中有更多的功能提取字节数据中的数据信息</p><p>（3）通过socket服务的receive方法将收到的数据存入已定义好的数据包中</p><p>（4）通过数据包对象的特有功能将这些不同的数据取出</p><p>（5）关闭资源</p><p><img src="/.com//桌面\SpringBootWeb\Snipaste_2019-09-18_00-31-47.png" alt="Snipaste_2019-09-18_00-31-47"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;如何建立在不同机器中的两个软件的通信？&lt;/p&gt;

      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot-日志</title>
    <link href="http://yoursite.com/2019/09/02/SpringBoot-%E6%97%A5%E5%BF%97/"/>
    <id>http://yoursite.com/2019/09/02/SpringBoot-日志/</id>
    <published>2019-09-02T15:48:56.996Z</published>
    <updated>2021-05-02T16:22:18.544Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="日志框架和选择"><a href="#日志框架和选择" class="headerlink" title="日志框架和选择"></a>日志框架和选择</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在进行大型项目的开发时。如果日志的文件记录的分散或者凌乱进行分散输出或者记录，不利于项目的日志管理</p><p>（1）日志应该进行统一的管理和配置-&gt;使用框架的方式对日志进行统一管理</p><p>（2）使用面向接口的编程方式对框架进行使用，项目中具体日志实现即可（类似JDBC）</p><h2 id="市面上的日志框架"><a href="#市面上的日志框架" class="headerlink" title="市面上的日志框架"></a>市面上的日志框架</h2><p>（1）市场上存在非常多的日志框架。JUL（java.util.logging），JCL（Apache Commons Logging），Log4j，Log4j2，Logback、SLF4j、jboss-logging等</p><p>（2）Spring Boot在框架内容部使用JCL，spring-boot-starter-logging采用了 slf4j+logback的形式，Spring Boot也能自动适配（jul、log4j2、logback） 并 简化配置</p><p><img src="/.com//桌面\SpringBoot视频2\Snipaste_2019-09-02_23-28-06.png" alt="Snipaste_2019-09-02_23-28-06"></p><p><strong>细节：</strong></p><p>（1）日志门面：日志的抽象层</p><p>（2）左边选一个门面右边选择一个实现</p><p>（3）SpringBoot：底层是Spring框架，Spring框架默认是用JCL；‘</p><p>​           <strong>SpringBoot选用 SLF4j和logback；</strong></p><h1 id="SLF4j使用"><a href="#SLF4j使用" class="headerlink" title="SLF4j使用"></a>SLF4j使用</h1><h2 id="如何在系统中使用SLF4j"><a href="#如何在系统中使用SLF4j" class="headerlink" title="如何在系统中使用SLF4j"></a>如何在系统中使用SLF4j</h2><p>在开发的时候，日志的记录方法的调用，不应该直接调用日志的实现类，而是调用日志抽象层的里面的方法。</p><p><a href="https://www.slf4j.org" target="_blank" rel="noopener">https://www.slf4j.org</a></p><p>给系统里面导入slf4j的jar和  logback的实现jar</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Logger logger = LoggerFactory.getLogger(HelloWorld.class);</span><br><span class="line">    logger.info(<span class="string">"Hello World"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SLF4J的实现图示（上文提到时SLF4J的logback实现）：</p><p><img src="/.com//桌面\SpringBoot视频2\concrete-bindings.png" alt="concrete-bindings"></p><p>注意</p><p>（1）深蓝颜色为实现层、绿色为适配层</p><p>（2）每一个日志实现框架都有自己的配置文件，使用SLF4J之后，配置文件还是做成日志实现框架的配置文件</p><h2 id="其他的日志框架转换为SLF4J"><a href="#其他的日志框架转换为SLF4J" class="headerlink" title="其他的日志框架转换为SLF4J"></a>其他的日志框架转换为SLF4J</h2><p><strong>遗留问题</strong></p><p>假设在开发的过程中如果开发了多个系统，那么系统中如果使用的框架不同那么他们用的日志记录框架也会有很大的差别。这时候每一个系统都有自己的日志记录框架，整合的时候就会出现日志框架杂乱，日志没有统一进行配置。</p><p><strong>如何统一日志记录使得别的框架也是使用SLF4J进行日志输出</strong></p><p>（1）将系统中其他日志框架先排除出去；</p><p>（2）用中间包来替换原有的日志框架；</p><p>（3）我们导入slf4j其他的实现</p><p><img src="/.com//桌面\SpringBoot视频2\Snipaste_2019-09-07_14-44-43.png" alt="Snipaste_2019-09-07_14-44-43"></p><h1 id="SpringBoot日志关系"><a href="#SpringBoot日志关系" class="headerlink" title="SpringBoot日志关系"></a>SpringBoot日志关系</h1><p>最基本的依赖（每一个启动器、场景都需要对其进行依赖）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/.com//桌面\SpringBoot视频2\Snipaste_2019-09-07_16-00-18.png" alt="Snipaste_2019-09-07_16-00-18"></p><p>SpringBoot使用它来做日志功能；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>底层依赖关系</p><p><img src="/.com//桌面\SpringBoot视频2\搜狗截图20180131220946.png" alt="搜狗截图20180131220946"></p><p>总结：</p><p>1）SpringBoot底层也是使用slf4j+logback的方式进行日志记录</p><p>2）SpringBoot也把其他的日志都替换成了slf4j；</p><p>3）中间替换包？（调用的是原来日志框架的方法名但是在新建对象的时候使用的是SLF4J的方式进行实现）</p><p>中间转换包图示：</p><p><img src="/.com//桌面\SpringBoot视频2\搜狗截图20180131221411.png" alt="搜狗截图20180131221411"></p><p>转换包底层实现原理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LogFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J = <span class="string">"http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> LogFactory logFactory = <span class="keyword">new</span> SLF4JLogFactory();</span><br></pre></td></tr></table></figure><p>4）SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志。</p><p>5）如果在开发的过程中需要引入其他的框架,那么一定要把引入的框架的日志依赖移除。原因是SpringBoot在底层的实现中已经存在和引入框架的同名转换包。这样就会引起冲突。</p><p><strong>示例</strong></p><p>Spring框架用的是commons-logging；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="SpringBoot日志默认配置"><a href="#SpringBoot日志默认配置" class="headerlink" title="SpringBoot日志默认配置"></a>SpringBoot日志默认配置</h1><p>（1）在没有对日志进行任何配置的时候，SpringBoot已经有了一个默认的配置。直接使用即可</p><p><strong>实例</strong></p><p>1）创建java文件、</p><p>​        获取日志记录器并使用日志记录器将日志进行输出。</p><p><img src="/.com//桌面\SpringBoot视频2\Snipaste_2019-09-07_16-11-01.png" alt="Snipaste_2019-09-07_16-11-01"></p><p>2）更改配置文件</p><p>更改配置文件设置日志的级别（level后面跟的是包名），以及日志文件的输出路径</p><p><img src="/.com//桌面\SpringBoot视频2\Snipaste_2019-09-07_16-39-30.png" alt="Snipaste_2019-09-07_16-39-30"></p><p>3）日志输出格式设置</p><p><img src="/.com//桌面\SpringBoot视频2\Snipaste_2019-09-07_16-50-03.png" alt="Snipaste_2019-09-07_16-50-03"></p><pre><code>日志输出格式：    %d表示日期时间，    %thread表示线程名，    %-5level：级别从左显示5个字符宽度    %logger{50} 表示logger名字最长50个字符，否则按照句点分割。     %msg：日志消息，    %n是换行符--&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n</code></pre><h1 id="指定日志文件和日志Profile功能"><a href="#指定日志文件和日志Profile功能" class="headerlink" title="指定日志文件和日志Profile功能"></a>指定日志文件和日志Profile功能</h1><h2 id="如何指定属于自己编写的日志配置文件？"><a href="#如何指定属于自己编写的日志配置文件？" class="headerlink" title="如何指定属于自己编写的日志配置文件？"></a>如何指定属于自己编写的日志配置文件？</h2><p>答：给类路径下放上每个日志框架自己的配置文件即可SpringBoot就不使用他默认配置了，而是直接使用日志框架的配置文件。如下图所示就是日志框架所对应的配置文件</p><p><img src="/.com//桌面\SpringBoot视频2\Snipaste_2019-09-07_23-47-27.png" alt="Snipaste_2019-09-07_23-47-27"></p><p>logback.xml：直接就被日志框架识别了；</p><h2 id="带上Spring扩展名的框架"><a href="#带上Spring扩展名的框架" class="headerlink" title="带上Spring扩展名的框架"></a>带上Spring扩展名的框架</h2><p><strong>logback-spring.xml</strong>：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级Profile功能，使得某段的配置内容在指定的环境下才能生效</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"staging"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- configuration to be enabled when the "staging" profile is active --&gt;</span></span><br><span class="line">  可以指定某段配置只在某个环境下生效</span><br><span class="line"><span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"stdout"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        日志输出格式：</span></span><br><span class="line"><span class="comment">%d表示日期时间，</span></span><br><span class="line"><span class="comment">%thread表示线程名，</span></span><br><span class="line"><span class="comment">%-5level：级别从左显示5个字符宽度</span></span><br><span class="line"><span class="comment">%logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 </span></span><br><span class="line"><span class="comment">%msg：日志消息，</span></span><br><span class="line"><span class="comment">%n是换行符</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.PatternLayout"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"dev"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ----&gt; [%thread] ---&gt; %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"!dev"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ==== [%thread] ==== %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>： 如果使用logback.xml作为日志配置文件，还要使用profile功能，会有以下错误</p><p> <code>no applicable action for [springProfile]</code></p><h1 id="切换日志框架"><a href="#切换日志框架" class="headerlink" title="切换日志框架"></a>切换日志框架</h1><h2 id="将使用中的SLF4j＋logback替换成SLF4J＋log4j进行使用"><a href="#将使用中的SLF4j＋logback替换成SLF4J＋log4j进行使用" class="headerlink" title="将使用中的SLF4j＋logback替换成SLF4J＋log4j进行使用"></a>将使用中的SLF4j＋logback替换成SLF4J＋log4j进行使用</h2><p><strong>参考图</strong></p><p><img src="/.com//桌面\SpringBoot视频2\Snipaste_2019-09-08_00-54-47.png" alt="Snipaste_2019-09-08_00-54-47"></p><p>（1）logback实现包依赖去除（pom.xml）</p><p><img src="/.com//桌面\SpringBoot视频2\Snipaste_2019-09-08_00-21-59.png" alt="Snipaste_2019-09-08_00-21-59"></p><p>（2）将log4j替换成slf4j的替换包移除依赖（里面的log4j都底层实现使用了受理费j）</p><p><img src="/.com//桌面\SpringBoot视频2\Snipaste_2019-09-08_00-23-14.png" alt="Snipaste_2019-09-08_00-23-14"></p><p>(3)将适配层依赖导入</p><p><img src="/.com//桌面\SpringBoot视频2\Snipaste_2019-09-08_00-52-47.png" alt="Snipaste_2019-09-08_00-52-47"></p><p>依赖图</p><p><img src="/.com//桌面\SpringBoot视频2\Snipaste_2019-09-08_00-54-06.png" alt="Snipaste_2019-09-08_00-54-06"></p><h2 id="切换成log4j2"><a href="#切换成log4j2" class="headerlink" title="切换成log4j2"></a>切换成log4j2</h2><p>(1)将原有的logging排除</p><p><img src="/.com//桌面\SpringBoot视频2\Snipaste_2019-09-08_00-59-44.png" alt="Snipaste_2019-09-08_00-59-44"></p><p>（2）添加log4j2</p><p><img src="/.com//桌面\SpringBoot视频2\Snipaste_2019-09-08_01-00-19.png" alt="Snipaste_2019-09-08_01-00-19"></p><p>（3）使用默认配置文件（或指定配置文件对日志进行配置），下图为默认配置文件</p><p><img src="/.com//桌面\SpringBoot视频2\Snipaste_2019-09-08_01-04-05.png" alt="Snipaste_2019-09-08_01-04-05"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;日志框架和选择&quot;&gt;&lt;a href=&quot;#日志框架和选择&quot; class=&quot;headerlink&quot; title=&quot;日志框架和选择&quot;&gt;&lt;/a&gt;日志框架和选择&lt;/h1&gt;&lt;h2 id=
      
    
    </summary>
    
      <category term="SpringBoot" scheme="http://yoursite.com/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot笔记" scheme="http://yoursite.com/tags/SpringBoot%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot-配置文件</title>
    <link href="http://yoursite.com/2019/09/01/SpringBoot-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2019/09/01/SpringBoot-配置文件/</id>
    <published>2019-09-01T08:03:08.113Z</published>
    <updated>2021-05-02T16:22:43.655Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>SpringBoot使用一个全局配置文件进行配置，配置文件可以对SpringBoot自动配置的一些默认的值进行修改。</p><p>（1）application.properties</p><p>（2）application.yml</p><p>注意：两种配置文件的名字都不能修改，是固定的</p><h3 id="细说"><a href="#细说" class="headerlink" title="细说"></a>细说</h3><p>YAML（YAML Ain’t Markup Language）</p><p>YAML Ain’t Markup Language解释：</p><pre><code>YAML  A Markup Language：是一个标记语言YAML   isn&apos;t Markup Language：不是一个标记语言；</code></pre><p>标记语言：</p><pre><code>以前的配置文件；大多都使用的是  xxxx.xml文件；YAML：以数据为中心，比json、xml等更适合做配置文件；</code></pre><p>以配置服务器端口号为例：</p><p>YAML：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8081</span></span><br></pre></td></tr></table></figure><p>XML：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">port</span>&gt;</span>8081<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="YAML语法"><a href="#YAML语法" class="headerlink" title="YAML语法"></a>YAML语法</h1><h2 id="1、基本语法"><a href="#1、基本语法" class="headerlink" title="1、基本语法"></a>1、基本语法</h2><p>k:(空格)v：表示一对键值对（空格必须有）；</p><p>以<strong>空格</strong>的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">8081</span>     <span class="string">//键值对，8081前面有一空格</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/hello</span></span><br></pre></td></tr></table></figure><p>属性和值也是大小写敏感；</p><h2 id="2、值的写法"><a href="#2、值的写法" class="headerlink" title="2、值的写法"></a>2、值的写法</h2><p><strong>（1）字面量：普通的值（数字，字符串，布尔）</strong></p><p>k: v：字面值直接来写；</p><p>1）字符串默认不用加上单引号或者双引号；</p><p>2）    “”：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思</p><p><strong>实例：name:   “zhangsan \n lisi”：输出；zhangsan 换行  lisi</strong></p><p>3）’’：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据</p><p><strong>实例：name:   ‘zhangsan \n lisi’：输出；zhangsan \n  lisi</strong></p><p><strong>（2）对象、Map（属性和值）（键值对）：</strong></p><pre><code>k: v：在下一行来写对象的属性和值的关系；注意缩进    对象还是k: v的方式</code></pre><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">friends:</span></span><br><span class="line"><span class="attr">lastName:</span> <span class="string">zhangsan</span></span><br><span class="line"><span class="attr">age:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><p>行内写法：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">friends:</span> <span class="string">&#123;lastName:</span> <span class="string">zhangsan,age:</span> <span class="number">18</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>（3）数组（List、Set）：</strong></p><p>用- 值表示数组中的一个元素</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pets:</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">cat</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">dog</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">pig</span></span><br></pre></td></tr></table></figure><p>行内写法</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pets:</span> <span class="string">[cat,dog,pig]</span></span><br></pre></td></tr></table></figure><h1 id="yaml配置文件值的获取"><a href="#yaml配置文件值的获取" class="headerlink" title="yaml配置文件值的获取"></a>yaml配置文件值的获取</h1><p>（1）创建Spring工程并编写一个属性类</p><p><img src="/.com//桌面\SpringBoot视频1\Snipaste_2019-09-01_16-04-49.png" alt="Snipaste_2019-09-01_16-04-49"></p><p>（2）为对象添加属性值</p><p><img src="/.com//桌面\SpringBoot视频1\Snipaste_2019-09-01_16-35-09.png" alt="Snipaste_2019-09-01_16-35-09"></p><p>（3）绑定配置文件中的属性配置</p><p> 1)prefix=”person”表示把配置文件中person前缀的配置信息注入</p><p> 2)注解中只用定义@component的组件才能使@ConfigurationProperties功能</p><p><img src="/.com//桌面\SpringBoot视频1\Snipaste_2019-09-01_16-33-54.png" alt="Snipaste_2019-09-01_16-33-54"></p><p>（4）添加配置文件处理器（用来生成配置文件的元素信息）</p><p>​       在导入配置文件处理器之后，配置文件设置属性就会出现提示</p><p><img src="/.com//桌面\SpringBoot视频1\Snipaste_2019-09-01_16-40-25.png" alt="Snipaste_2019-09-01_16-40-25"></p><p>（5） 编写测试类</p><p><img src="/.com//桌面\SpringBoot视频1\Snipaste_2019-09-01_17-05-25.png" alt="Snipaste_2019-09-01_17-05-25"></p><h1 id="properties配置文件"><a href="#properties配置文件" class="headerlink" title="properties配置文件"></a>properties配置文件</h1><p>（1）设置properties编码</p><p>因为properties是属于Ascii码进行编程的，但是在开发环境中又是使用到了utf-8的编码方式。所以需要进行设置将运行时期的编码转换为Ascill码</p><p><img src="/.com//桌面\SpringBoot视频1\Snipaste_2019-09-01_19-26-10.png" alt="Snipaste_2019-09-01_19-26-10"></p><p>（2）添加设置属性的方式如图所示</p><p><img src="/.com//桌面\SpringBoot视频1\Snipaste_2019-09-01_19-44-05.png" alt="Snipaste_2019-09-01_19-44-05"></p><h1 id="绑定属性的另外一种方式"><a href="#绑定属性的另外一种方式" class="headerlink" title="绑定属性的另外一种方式"></a>绑定属性的另外一种方式</h1><p>（1）在每个属性的上方添加@value注解，向属性添加数据</p><p><img src="/.com//桌面\SpringBoot视频1\Snipaste_2019-09-01_21-52-57.png" alt="Snipaste_2019-09-01_21-52-57"></p><p>（2）@ConfigurationProperties和@Value获取值比较</p><table><thead><tr><th></th><th>@ConfigurationProperties</th><th>@Value</th></tr></thead><tbody><tr><td>功能</td><td>批量注入配置文件中的属性</td><td>一个个指定</td></tr><tr><td>松散绑定（松散语法）</td><td>支持</td><td>不支持</td></tr><tr><td>SpEL(Spring表达式)</td><td>不支持</td><td>支持</td></tr><tr><td>JSR303数据校验</td><td>支持</td><td>不支持</td></tr><tr><td>复杂类型封装</td><td>支持</td><td>不支持</td></tr></tbody></table><p><strong>JSR303校验实例：</strong></p><p><img src="/.com//桌面\SpringBoot视频1\Snipaste_2019-09-02_00-14-10.png" alt="Snipaste_2019-09-02_00-14-10"></p><p>配置文件yml还是properties他们都能获取到值；</p><p>（1）如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value（基本数据类型）；</p><p>（2）如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties；</p><h1 id="PropertySource和-ImportanceResource"><a href="#PropertySource和-ImportanceResource" class="headerlink" title="@PropertySource和@ImportanceResource"></a>@PropertySource和@ImportanceResource</h1><h2 id="PropertySource"><a href="#PropertySource" class="headerlink" title="@PropertySource"></a>@PropertySource</h2><p>介绍：如果工程的所有配置文件都在全局配置文件中进行配置就会显得全局配置文件的繁杂，这时候就需要创建普通配置文件进行对相关数据的配置。</p><p>作用：加载指定的配置文件</p><p><strong>实例：</strong></p><p><img src="/.com//桌面\SpringBoot视频1\Snipaste_2019-09-02_00-26-12.png" alt="Snipaste_2019-09-02_00-26-12"></p><h2 id="ImportanceResource"><a href="#ImportanceResource" class="headerlink" title="@ImportanceResource"></a>@ImportanceResource</h2><p>作用：导入Spring配置文件，让配置文件里面的内容生效</p><p>介绍：</p><p>（1）Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别；</p><p>（2）想让Spring的配置文件生效，加载进来；@<strong>ImportResource</strong>标注在一个配置类上</p><p><strong>实例</strong></p><p>参数是一个数组，可以加载多个配置文件</p><p><img src="/.com//桌面\SpringBoot视频1\Snipaste_2019-09-02_00-33-18.png" alt="Snipaste_2019-09-02_00-33-18"></p><h1 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h1><p>在SpringBoot中推荐使用以配置类的方式进行配置开发</p><p>配置类==配置文件</p><p>使用@Bean给容器中添加组件</p><p><strong>实例：<img src="/.com//桌面\SpringBoot视频1\Snipaste_2019-09-02_00-41-17.png" alt="Snipaste_2019-09-02_00-41-17"></strong></p><h1 id="配置文件的占位符"><a href="#配置文件的占位符" class="headerlink" title="配置文件的占位符"></a>配置文件的占位符</h1><p>1、随机数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;random.value&#125;、$&#123;random.<span class="keyword">int</span>&#125;、$&#123;random.<span class="keyword">long</span>&#125;</span><br><span class="line">$&#123;random.<span class="keyword">int</span>(<span class="number">10</span>)&#125;、$&#123;random.<span class="keyword">int</span>[<span class="number">1024</span>,<span class="number">65536</span>]&#125;</span><br></pre></td></tr></table></figure><p>2、占位符获取之前配置的值，如果没有可以是用:指定默认值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">person.last-name=张三$&#123;random.uuid&#125;</span><br><span class="line">person.age=$&#123;random.int&#125;</span><br><span class="line">person.birth=2017/12/15</span><br><span class="line">person.boss=false</span><br><span class="line">person.maps.k1=v1</span><br><span class="line">person.maps.k2=14</span><br><span class="line">person.lists=a,b,c</span><br><span class="line">person.dog.name=$&#123;person.hello:hello&#125;_dog</span><br><span class="line">person.dog.age=15</span><br></pre></td></tr></table></figure><h1 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h1><h2 id="1、多Profile文件"><a href="#1、多Profile文件" class="headerlink" title="1、多Profile文件"></a>1、多Profile文件</h2><p>介绍</p><p>在进行生产和开发阶段的时候可能配置的数据内容有所差异这时候就使用到了多Profile文件进行配置生产和开发不同阶段的文件</p><p>命名</p><p>在主配置文件编写的时候，文件名可以是   application-{profile}.properties/yml</p><p><strong>默认使用application.properties的配置；</strong></p><p><strong>实例</strong></p><p><img src="/.com//桌面\SpringBoot视频1\Snipaste_2019-09-02_00-57-46.png" alt="Snipaste_2019-09-02_00-57-46"></p><h2 id="2、yml支持多文档块方式"><a href="#2、yml支持多文档块方式" class="headerlink" title="2、yml支持多文档块方式"></a>2、yml支持多文档块方式</h2><p><img src="/.com//桌面\SpringBoot视频1\Snipaste_2019-09-02_01-06-16.png" alt="Snipaste_2019-09-02_01-06-16"></p><h2 id="3、激活指定profile"><a href="#3、激活指定profile" class="headerlink" title="3、激活指定profile"></a>3、激活指定profile</h2><p>1）在配置文件中指定  spring.profiles.active=dev</p><p>2）命令行：</p><p>​    java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar –spring.profiles.active=dev；</p><p>​    可以直接在测试的时候，配置传入命令行参数</p><p>3）虚拟机参数；</p><p>​    -Dspring.profiles.active=dev</p><p><strong>其中第二第三种均可以通过设置主配置类的方式进行设置</strong></p><p><img src="/.com//桌面\SpringBoot视频1\Snipaste_2019-09-02_01-13-58.png" alt="Snipaste_2019-09-02_01-13-58"></p><h1 id="配置文件的加载位置"><a href="#配置文件的加载位置" class="headerlink" title="配置文件的加载位置"></a>配置文件的加载位置</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p>springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件</p><p>（1）–file:./config/                  当前项目路径下的config目录下</p><p>（2）–file:./                               当前项目路径下</p><p>（3）–classpath:/config/         当前类目录下的config目录下</p><p>（4）–classpath:/                       当前类目录下</p><p><strong>优先级由高到低，高优先级的配置会覆盖低优先级的配置；</strong></p><p>SpringBoot会从这四个位置全部加载主配置文件；</p><p><strong>互补配置</strong>：低优先级的配置文件也会被扫描，将高优先级没有的配置加载进来</p><h2 id="通过spring-config-location来改变默认的配置文件位置"><a href="#通过spring-config-location来改变默认的配置文件位置" class="headerlink" title="通过spring.config.location来改变默认的配置文件位置"></a>通过spring.config.location来改变默认的配置文件位置</h2><p>在项目已经启动的时候，如果需要对配置进行修改或者添加配置（互补配置），那么通过命令行运行jar包加入spring.config.location参数的方式进行修改默认配置文件即可</p><p><strong>实例</strong></p><p><img src="/.com//桌面\SpringBoot视频1\Snipaste_2019-09-02_01-28-06.png" alt="Snipaste_2019-09-02_01-28-06"></p><h2 id="外部配置加载顺序"><a href="#外部配置加载顺序" class="headerlink" title="外部配置加载顺序"></a>外部配置加载顺序</h2><p><strong>SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置</strong></p><p><strong>1.命令行参数</strong></p><p>所有的配置都可以在命令行上进行指定</p><p><strong>实例</strong></p><p>java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –server.port=8087  –server.context-path=/abc</p><p><strong>语法</strong></p><p>多个配置用空格分开； –配置项=值</p><p>2.来自java:comp/env的JNDI属性</p><p>3.Java系统属性（System.getProperties()）</p><p>4.操作系统环境变量</p><p>5.RandomValuePropertySource配置的random.*属性值</p><p><strong>由jar包外向jar包内进行寻找；</strong></p><p><strong>优先加载带profile</strong></p><p><strong>6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件</strong></p><p><strong>7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件</strong></p><p><strong>再来加载不带profile</strong></p><p><strong>8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件</strong></p><p><strong>9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件</strong></p><p>10.@Configuration注解类上的@PropertySource</p><p>11.通过SpringApplication.setDefaultProperties指定的默认属性</p><p>所有支持的配置加载来源；</p><p><a href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#boot-features-external-config" target="_blank" rel="noopener">参考官方文档</a></p><h1 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="自动配置原理"></a>自动配置原理</h1><p>配置文件到底能写什么？怎么写？自动配置原理；</p><p><a href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#common-application-properties" target="_blank" rel="noopener">配置文件能配置的属性参照</a></p><h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a><strong>原理：</strong></h2><p>1）SpringBoot启动的时候加载主配置类，开启了自动配置功能 @EnableAutoConfiguration</p><p><strong>2）@EnableAutoConfiguration 作用：</strong></p><ul><li>利用EnableAutoConfigurationImportSelector给容器中导入一些组件？</li></ul><ul><li><p>可以查看selectImports()方法的内容；</p></li><li><p>List<string> configurations = getCandidateConfigurations(annotationMetadata,      attributes);获取候选的配置</string></p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SpringFactoriesLoader.loadFactoryNames()</span><br><span class="line">扫描所有jar包类路径下  META-INF/spring.factories</span><br><span class="line">把扫描到的这些文件的内容包装成properties对象</span><br><span class="line">从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中</span><br></pre></td></tr></table></figure></li></ul><p><strong>将 类路径下  META-INF/spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中；</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration</span><br></pre></td></tr></table></figure><p>每一个这样的  xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置；</p><p>3）、每一个自动配置类进行自动配置功能；</p><p>4）、以<strong>HttpEncodingAutoConfiguration（Http编码自动配置）</strong>为例解释自动配置原理；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>   <span class="comment">//表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(HttpEncodingProperties.class)  <span class="comment">//启动指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；并把HttpEncodingProperties加入到ioc容器中</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span> <span class="comment">//Spring底层@Conditional注解（Spring注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效；    判断当前应用是否是web应用，如果是，当前配置类生效</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(CharacterEncodingFilter.class)  <span class="comment">//判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.http.encoding"</span>, value = <span class="string">"enabled"</span>, matchIfMissing = <span class="keyword">true</span>)  <span class="comment">//判断配置文件中是否存在某个配置  spring.http.encoding.enabled；如果不存在，判断也是成立的</span></span><br><span class="line"><span class="comment">//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpEncodingAutoConfiguration</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//他已经和SpringBoot的配置文件映射了</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> HttpEncodingProperties properties;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">//只有一个有参构造器的情况下，参数的值就会从容器中拿</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HttpEncodingAutoConfiguration</span><span class="params">(HttpEncodingProperties properties)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.properties = properties;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Bean</span>   <span class="comment">//给容器中添加一个组件，这个组件的某些值需要从properties中获取</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(CharacterEncodingFilter.class) <span class="comment">//判断容器没有这个组件？</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CharacterEncodingFilter <span class="title">characterEncodingFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">CharacterEncodingFilter filter = <span class="keyword">new</span> OrderedCharacterEncodingFilter();</span><br><span class="line">filter.setEncoding(<span class="keyword">this</span>.properties.getCharset().name());</span><br><span class="line">filter.setForceRequestEncoding(<span class="keyword">this</span>.properties.shouldForce(Type.REQUEST));</span><br><span class="line">filter.setForceResponseEncoding(<span class="keyword">this</span>.properties.shouldForce(Type.RESPONSE));</span><br><span class="line"><span class="keyword">return</span> filter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据当前不同的条件判断，决定这个配置类是否生效？</p><p>一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的；</p><p>5）、所有在配置文件中能配置的属性都是在xxxxProperties类中封装者‘；配置文件能配置什么就可以参照某个功能对应的这个属性类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.http.encoding"</span>)  <span class="comment">//从配置文件中获取指定的值和bean的属性进行绑定</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpEncodingProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Charset DEFAULT_CHARSET = Charset.forName(<span class="string">"UTF-8"</span>);</span><br></pre></td></tr></table></figure><p><strong>精髓：</strong></p><pre><code>1）、SpringBoot启动会加载大量的自动配置类2）、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类；3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了）4）、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值；</code></pre><p>xxxxAutoConfigurartion：自动配置类；</p><p>给容器中添加组件</p><p>xxxxProperties:封装配置文件中相关属性；</p><h3 id="2、细节"><a href="#2、细节" class="headerlink" title="2、细节"></a>2、细节</h3><h4 id="1、-Conditional派生注解（Spring注解版原生的-Conditional作用）"><a href="#1、-Conditional派生注解（Spring注解版原生的-Conditional作用）" class="headerlink" title="1、@Conditional派生注解（Spring注解版原生的@Conditional作用）"></a>1、@Conditional派生注解（Spring注解版原生的@Conditional作用）</h4><p>作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效；</p><table><thead><tr><th>@Conditional扩展注解</th><th>作用（判断是否满足当前指定条件）</th></tr></thead><tbody><tr><td>@ConditionalOnJava</td><td>系统的java版本是否符合要求</td></tr><tr><td>@ConditionalOnBean</td><td>容器中存在指定Bean；</td></tr><tr><td>@ConditionalOnMissingBean</td><td>容器中不存在指定Bean；</td></tr><tr><td>@ConditionalOnExpression</td><td>满足SpEL表达式指定</td></tr><tr><td>@ConditionalOnClass</td><td>系统中有指定的类</td></tr><tr><td>@ConditionalOnMissingClass</td><td>系统中没有指定的类</td></tr><tr><td>@ConditionalOnSingleCandidate</td><td>容器中只有一个指定的Bean，或者这个Bean是首选Bean</td></tr><tr><td>@ConditionalOnProperty</td><td>系统中指定的属性是否有指定的值</td></tr><tr><td>@ConditionalOnResource</td><td>类路径下是否存在指定资源文件</td></tr><tr><td>@ConditionalOnWebApplication</td><td>当前是web环境</td></tr><tr><td>@ConditionalOnNotWebApplication</td><td>当前不是web环境</td></tr><tr><td>@ConditionalOnJndi</td><td>JNDI存在指定项</td></tr></tbody></table><p><strong>自动配置类必须在一定的条件下才能生效；</strong></p><p>怎么知道哪些自动配置类生效？</p><p><strong>通过启用  debug=true属性；来让控制台打印自动配置报告</strong>，这样我们就可以很方便的知道哪些自动配置类生效；</p><p><img src="/.com//桌面\SpringBoot视频1\Snipaste_2019-09-02_02-04-44.png" alt="Snipaste_2019-09-02_02-04-44"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">=========================</span><br><span class="line">AUTO-CONFIGURATION REPORT</span><br><span class="line">=========================</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Positive matches:（自动配置类启用的）</span><br><span class="line">-----------------</span><br><span class="line"></span><br><span class="line">   DispatcherServletAutoConfiguration matched:</span><br><span class="line">      - <span class="meta">@ConditionalOnClass</span> found required <span class="class"><span class="keyword">class</span> '<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">servlet</span>.<span class="title">DispatcherServlet</span>'</span>; <span class="meta">@ConditionalOnMissingClass</span> <span class="function">did not find unwanted <span class="title">class</span> <span class="params">(OnClassCondition)</span></span></span><br><span class="line"><span class="function">      - @<span class="title">ConditionalOnWebApplication</span> <span class="params">(required)</span> found <span class="title">StandardServletEnvironment</span> <span class="params">(OnWebApplicationCondition)</span></span></span><br><span class="line"><span class="function">        </span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">Negative matches:（没有启动，没有匹配成功的自动配置类）</span></span><br><span class="line"><span class="function">-----------------</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">   ActiveMQAutoConfiguration:</span></span><br><span class="line"><span class="function">      Did not match:</span></span><br><span class="line"><span class="function">         - @ConditionalOnClass did not find required classes 'javax.jms.ConnectionFactory', 'org.apache.activemq.ActiveMQConnectionFactory' <span class="params">(OnClassCondition)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">   AopAutoConfiguration:</span></span><br><span class="line"><span class="function">      Did not match:</span></span><br><span class="line"><span class="function">         - @ConditionalOnClass did not find required classes 'org.aspectj.lang.annotation.Aspect', 'org.aspectj.lang.reflect.Advice' <span class="params">(OnClassCondition)</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;配置文件&quot;&gt;&lt;a href=&quot;#配置文件&quot; class=&quot;headerlink&quot; title=&quot;配置文件&quot;&gt;&lt;/a&gt;配置文件&lt;/h1&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="SpringBoot" scheme="http://yoursite.com/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot笔记" scheme="http://yoursite.com/tags/SpringBoot%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot-入门与第一个Hello工程</title>
    <link href="http://yoursite.com/2019/08/31/SpringBoot-%E5%85%A5%E9%97%A8%E4%B8%8E%E7%AC%AC%E4%B8%80%E4%B8%AAHelloWorld%E5%B7%A5%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/08/31/SpringBoot-入门与第一个HelloWorld工程/</id>
    <published>2019-08-31T15:05:32.839Z</published>
    <updated>2021-05-02T16:21:32.609Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="SpringBoot简介与优点"><a href="#SpringBoot简介与优点" class="headerlink" title="SpringBoot简介与优点"></a>SpringBoot简介与优点</h1><h2 id="什么是Spring-Boot"><a href="#什么是Spring-Boot" class="headerlink" title="什么是Spring Boot"></a>什么是Spring Boot</h2><p>Spring Boot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化新 Spring 应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。其实就是 Spring Boot 其实不是新的框架，它默认配置了很多框架的使用方式，就像 Maven 整合了所有的 Jar 包，Spring Boot 整合了所有的框架。J2EE的一站式开发解决方案</p><h2 id="使用SpringBoot的优点"><a href="#使用SpringBoot的优点" class="headerlink" title="使用SpringBoot的优点"></a>使用SpringBoot的优点</h2><p>（1）快速创建独立运行的Spring 项目以及与主流框架集成</p><p>（2）使用嵌入式的Servlet，应用无需打包war包</p><p>（3）starters自动依赖与版本控制</p><p>（4）大量自动配置，简化开发，也可以修改默认值</p><p>（5）无需配置XML，无需代码生成，开箱即用</p><p>（6）准生产环境的运行时应用监控</p><p>（7）与云计算天然集成</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>只有对Spring的底层的API有充分的了解的情况下才可以实现对SpringBoot的深度定制开发。以及对SpringBoot的熟练使用</p><h1 id="Spring-Boot微服务简介"><a href="#Spring-Boot微服务简介" class="headerlink" title="Spring Boot微服务简介"></a>Spring Boot微服务简介</h1><p>SringBoot提供了系列的微服务解决方案，可以使得开发中快速地构建微服务</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间相互协调、互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务和服务之间采用轻量级的通信机制相互沟通（通常是基于HTTP的Restful API).每个服务都围绕着具体的业务进行构建，并且能够被独立的部署到生产环境、类生产环境等。另外，应尽量避免统一的、集中的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构</p><h2 id="微服务的特征与界定"><a href="#微服务的特征与界定" class="headerlink" title="微服务的特征与界定"></a>微服务的特征与界定</h2><p><img src="/.com//桌面\SpringBoot视频1\Snipaste_2019-08-31_23-11-44.png" alt="Snipaste_2019-08-31_23-11-44"></p><h2 id="单体应用-vs-微服务架构"><a href="#单体应用-vs-微服务架构" class="headerlink" title="单体应用 vs 微服务架构"></a>单体应用 vs 微服务架构</h2><p><strong>优点</strong></p><ol><li>提升开发交流，每个服务足够内聚，足够小，代码容易理解；</li><li>服务独立测试、部署、升级、发布；</li><li>按需定制的DFX，资源利用率，每个服务可以各自进行x扩展和z扩展，而且，每个服务可以根据自己的需要部署到合适的硬件服务器上；每个服务按</li><li>需要选择HA的模式，选择接受服务的实例个数；</li><li>容易扩大开发团队，可以针对每个服务（service）组件开发团队；</li><li>提高容错性（fault isolation），一个服务的内存泄露并不会让整个系统瘫痪；</li><li>新技术的应用，系统不会被长期限制在某个技术栈上；</li></ol><p><strong>缺点</strong></p><ol><li>没有银弹，微服务提高了系统的复杂度；</li><li>开发人员要处理分布式系统的复杂性；</li><li>服务之间的分布式通信问题；</li><li>服务的注册与发现问题；</li><li>服务之间的分布式事务问题；</li><li>数据隔离再来的报表处理问题；</li><li>服务之间的分布式一致性问题；</li><li>服务管理的复杂性，服务的编排；</li><li>不同服务实例的管理。</li></ol><h1 id="SpringBoot环境准备"><a href="#SpringBoot环境准备" class="headerlink" title="SpringBoot环境准备"></a>SpringBoot环境准备</h1><h2 id="环境约束（本文中所涉及到的项目开发的环境）"><a href="#环境约束（本文中所涉及到的项目开发的环境）" class="headerlink" title="环境约束（本文中所涉及到的项目开发的环境）"></a>环境约束（本文中所涉及到的项目开发的环境）</h2><p>–jdk1.8：Spring Boot 推荐jdk1.7及以上；java version “1.8.0_112”</p><p>–maven3.x：maven 3.3以上版本；Apache Maven 3.3.9</p><p>–IntelliJIDEA2017：IntelliJ IDEA 2017.2.2 x64、STS</p><p>–SpringBoot 1.5.9.RELEASE：1.5.9；</p><h2 id="MAVEN设置"><a href="#MAVEN设置" class="headerlink" title="MAVEN设置"></a>MAVEN设置</h2><p>给maven 的settings.xml配置文件的profiles标签添加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="IDEA设置"><a href="#IDEA设置" class="headerlink" title="IDEA设置"></a>IDEA设置</h2><p><img src="/.com//桌面\SpringBoot视频1\Snipaste_2019-08-31_23-24-54.png" alt="Snipaste_2019-08-31_23-24-54"></p><h1 id="SpringBoot-HelloWorld"><a href="#SpringBoot-HelloWorld" class="headerlink" title="SpringBoot HelloWorld"></a>SpringBoot HelloWorld</h1><p>需求：浏览器发送Hello请求，服务器接受请求并处理，响应HelloWorld字符串。</p><h2 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h2><p>（1）创建Maven工程</p><p>（2）导入spring boot相关的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（3）编写一个主程序启动SpringBoot</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@SpringBootApplication</span> 来标注一个主程序类，说明这是一个Spring Boot应用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldMainApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Spring应用启动起来</span></span><br><span class="line">        SpringApplication.run(HelloWorldMainApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）编写相关的Controller、Service</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="comment">//接收来自浏览器的hello请求</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）运行主方法</p><p>运行成功，控制台提示Tomcat已经成功运行，并在浏览器中输入如下数据，便可成功实现功能</p><p><img src="/.com//桌面\SpringBoot视频1\Snipaste_2019-08-31_23-46-24.png" alt="Snipaste_2019-08-31_23-46-24"></p><p>（5）运行主程序测试</p><p>（6）简化部署</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这个插件，可以将应用打包成一个可执行的jar包；--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​           将这个应用打成jar包，直接使用java -jar的命令进行执行；</p><h2 id="HelloWorld探究"><a href="#HelloWorld探究" class="headerlink" title="HelloWorld探究"></a>HelloWorld探究</h2><p>1、POM文件</p><p>父项目</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">他的父项目是</span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../../spring-boot-dependencies<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">他来真正管理Spring Boot应用里面的所有依赖版本；</span><br></pre></td></tr></table></figure><p>2、启动器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>spring-boot-starter</strong>：</p><pre><code>spring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件；Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器</code></pre><p>3、主程序类，主入口类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@SpringBootApplication</span> 来标注一个主程序类，说明这是一个Spring Boot应用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldMainApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Spring应用启动起来</span></span><br><span class="line">        SpringApplication.run(HelloWorldMainApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@<strong>SpringBootApplication</strong>:    Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123;</span><br><span class="line">      <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="line">      <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br></pre></td></tr></table></figure><p>@<strong>SpringBootConfiguration</strong>:Spring Boot的配置类；</p><pre><code>  标注在某个类上，表示这是一个Spring Boot的配置类；  @Configuration:配置类上来标注这个注解；配置类 -----  配置文件；配置类也是容器中的一个组件；@Component</code></pre><p>@<strong>EnableAutoConfiguration</strong>：开启自动配置功能；</p><pre><code>以前我们需要配置的东西，Spring Boot帮我们自动配置；@**EnableAutoConfiguration**告诉SpringBoot开启自动配置功能；这样自动配置才能生效；</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(EnableAutoConfigurationImportSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br></pre></td></tr></table></figure><pre><code>  @**AutoConfigurationPackage**：自动配置包@**Import**(AutoConfigurationPackages.Registrar.class)：Spring的底层注解@Import，给容器中导入一个组件；导入的组件由AutoConfigurationPackages.Registrar.class；</code></pre><p>==将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；==</p><pre><code>@**Import**(EnableAutoConfigurationImportSelector.class)；    给容器中导入组件？    **EnableAutoConfigurationImportSelector**：导入哪些组件的选择器；    将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中；    会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件；    有了自动配置类，免去了我们手动编写配置注入功能组件等的工作；    SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader)；</code></pre><p>==Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；==</p><p>以前我们需要自己配置的东西，自动配置类都帮我们；</p><p>J2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure-1.5.9.RELEASE.jar；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;SpringBoot简介与优点&quot;&gt;&lt;a href=&quot;#SpringBoot简介与优点&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot简介与优点&quot;
      
    
    </summary>
    
      <category term="SpringBoot" scheme="http://yoursite.com/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot笔记" scheme="http://yoursite.com/tags/SpringBoot%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Spring框架-Spring的配置</title>
    <link href="http://yoursite.com/2019/08/11/Spring%E6%A1%86%E6%9E%B6-Spring%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/08/11/Spring框架-Spring的配置/</id>
    <published>2019-08-11T06:56:49.034Z</published>
    <updated>2019-08-11T08:37:29.496Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="XML提示配置"><a href="#XML提示配置" class="headerlink" title="XML提示配置"></a>XML提示配置</h1><p><strong>为eclipse添加Schema的提示配置</strong></p><p>配置步骤如下</p><p>（1）复制配Schema地址</p><p>（如果没有配置文件，可以自己敲或者到Spring的解压目录下的spring-framework-5.1.9.RELEASE/docs/spring-framework-reference/core.html#spring-core查找）</p><p><img src="https://img-blog.csdnimg.cn/2019081116231227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>（2）添加xml用户指定条目</p><p><img src="https://img-blog.csdnimg.cn/2019081116232256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>(3)添加Schema路径、本地文件路径</p><p>注意：橙色框框内的Schame location在完成添加路径和地址时eclipse才会有该选项供给用户选择</p><p><img src="https://img-blog.csdnimg.cn/20190811162332761.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="bean的相关配置"><a href="#bean的相关配置" class="headerlink" title="bean的相关配置"></a>bean的相关配置</h1><h2 id="标签的id和name-的配置"><a href="#标签的id和name-的配置" class="headerlink" title="标签的id和name 的配置"></a><bean>标签的id和name 的配置</bean></h2><p>（1）id：使用了月生杜仲的唯一约束，里面不能出现特殊字符</p><p>（2）name：没有使用约束中的唯一约束（理论上可以出现重复，但是在实际的开发过程中不允许出现重复）</p><p><strong>两者的联系和区别</strong></p><p>在一般的使用情况下可以认为两者是一样的实现的是一样的功能，但是在如果配置文件的id必须是含有特殊字符的情况下进行定义这就需要切换至name来使用了</p><h2 id="bean的生命周期的配置（了解）"><a href="#bean的生命周期的配置（了解）" class="headerlink" title="bean的生命周期的配置（了解）"></a>bean的生命周期的配置（了解）</h2><p>步骤：</p><p>（1）首先在需要进行实例化的类中定义初始化方法以及销毁调用的方法</p><p>（不需要是接口中的方法，只需要是接口实现类的特有属性即可）</p><p>（2）在配置文件中配置初始化调用方法</p><p><img src="https://img-blog.csdnimg.cn/20190811162345941.png" alt="在这里插入图片描述"></p><p>（3）初始化调用方法会在对象被创建的时候进行调用，销毁方法在对象在销毁的时候被调用，如将类工厂关闭</p><p><img src="https://img-blog.csdnimg.cn/20190811162353749.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="bean的作用范围的配置（重点）"><a href="#bean的作用范围的配置（重点）" class="headerlink" title="bean的作用范围的配置（重点）"></a>bean的作用范围的配置（重点）</h2><p>scope属性进行配置Bean的作用范围</p><p>scope有以下的几个数值</p><p>（1）singleton :默认的，Spring会采用单例模式创建这个对象</p><p>（2）prototype：多例模式（Struts2和Spring整合一定会用到）</p><p>（3）request: 应用在web项目中，Spring创建这个类以后就会将它存入到request范围中</p><p>（4）session：应用在web项目中，Spring创建这个类以后就会将它存入到session范围中</p><p>（5）globalsession：应用在web项目，必须在prolet环境下使用，如果没有这种环境，但是又将其配置为了这个属性，时候相当于session。</p><p><strong>注意</strong>：</p><p>（1）prolet环境指的是在一个网站有多个页面的情况下，一次配置，全局页面共享。如在淘宝页面登录了账号,在浏览商品的各个页面上都显示已登录信息</p><p>（2）在实际的开发中主要使用的是第一第二个属性进行配置</p><p><strong>实例</strong></p><p>（1）在默认的情况下，即不进行配置的情况下。创建的对象是单例的。这时候不管获取对象多少次都是同一个对象，如下图所示，两次获取的对象的地址是相同的，对象只被初始化一次</p><p><img src="https://img-blog.csdnimg.cn/20190811162406746.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>（2）将对象配置为多例模式的</p><p>1）将配置文件中对scope的属性修改为prototype</p><p><img src="https://img-blog.csdnimg.cn/2019081116241755.png" alt="在这里插入图片描述"></p><p>2）在对上面的获取两次对象代码进行运行，初始化了两次，同时地址也是不一样的。</p><p><img src="https://img-blog.csdnimg.cn/20190811162429277.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>注意</strong>：这时候工厂虽然关闭了，但是对象并没有销毁，原因是工厂不知道对哪一个对象进行销毁</p><h1 id="Spring的属性注入"><a href="#Spring的属性注入" class="headerlink" title="Spring的属性注入"></a>Spring的属性注入</h1><h2 id="属性注入的方式"><a href="#属性注入的方式" class="headerlink" title="属性注入的方式"></a>属性注入的方式</h2><p>在java的开发中，有下图的几种方式实现对象的属性注入，其中Spring支持构造方法和set方法两种方式进行属性注入。</p><p><img src="https://img-blog.csdnimg.cn/20190811162439522.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="构造方法方式的属性注入"><a href="#构造方法方式的属性注入" class="headerlink" title="构造方法方式的属性注入"></a>构造方法方式的属性注入</h2><p>（1）定义一个类，并使用构造方法的方式对属性进行设置，如下图</p><p><img src="https://img-blog.csdnimg.cn/20190811162446935.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>（2）在对应的<bean>标签中添加<constructor-arg> 进行对属性的注入</constructor-arg></bean></p><p><img src="https://img-blog.csdnimg.cn/20190811162453447.png" alt="在这里插入图片描述"></p><h2 id="set方法的方式的属性注入"><a href="#set方法的方式的属性注入" class="headerlink" title="set方法的方式的属性注入"></a>set方法的方式的属性注入</h2><p>（1）定义一个类，并使用set方法的方式对属性进行注入</p><p><img src="https://img-blog.csdnimg.cn/20190811162501595.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>（2）在配置文件中对应的<bean>标签中添加<property>标签对属性进行注入</property></bean></p><p><img src="https://img-blog.csdnimg.cn/20190811162508447.png" alt="在这里插入图片描述"></p><h2 id="set方法注入对象类型的属性"><a href="#set方法注入对象类型的属性" class="headerlink" title="set方法注入对象类型的属性"></a>set方法注入对象类型的属性</h2><p>（1）定义一个类，这个类的中存在一个对象属性，同时该对象由set方法的方式获得</p><p><img src="https://img-blog.csdnimg.cn/20190811162526895.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>（2）在配置文件中找到对应的<bean>标签，并添加<propertyt>进行对属性注入。但是因为注入的是对象属性，所以只能是使用ref的方式指向配置的对象id，如下图所示</propertyt></bean></p><p><img src="https://img-blog.csdnimg.cn/20190811162535890.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>注意</strong>：使用构造方法设置对象属性也是类似的方法，把value改成ref即可</p><h2 id="P名称空间的属性注入方式（Spring2-5以后）"><a href="#P名称空间的属性注入方式（Spring2-5以后）" class="headerlink" title="P名称空间的属性注入方式（Spring2.5以后）"></a>P名称空间的属性注入方式（Spring2.5以后）</h2><p>介绍：通过引入p名称空间完成属性的注入</p><p>语法：</p><p>​    （1）普通属性   p:属性名=”值”</p><p>​     （2）对象属性   p:属性名-ref=”值”</p><p><strong>实例</strong></p><p>（1）打开配置文件并添加P名称空间</p><p><img src="https://img-blog.csdnimg.cn/20190811162546581.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>（2）修改配置文件将注入属性的方法写为p名称空间的方式</p><p>1）普通属性注入</p><p><img src="https://img-blog.csdnimg.cn/20190811162555715.png" alt="在这里插入图片描述"></p><p>2）对象属性注入</p><p><img src="https://img-blog.csdnimg.cn/20190811162603809.png" alt="在这里插入图片描述"></p><h2 id="SpEL的属性注入（Spring3-0以后的版本）"><a href="#SpEL的属性注入（Spring3-0以后的版本）" class="headerlink" title="SpEL的属性注入（Spring3.0以后的版本）"></a>SpEL的属性注入（Spring3.0以后的版本）</h2><p>介绍:Spring Expression Language,Spring 的表达式语言</p><p>语法：</p><p>​       （1）#{SpEL}</p><p><strong>实例</strong></p><p>（1）在配置文件中将普通属性进行注入操作</p><p><img src="https://img-blog.csdnimg.cn/20190811162614475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>（2）对象属性注入</p><p><img src="https://img-blog.csdnimg.cn/20190811162629125.png" alt="在这里插入图片描述"></p><p>（3）对象属性和对象方法的调用</p><p>被调用的对象必须在配置文件中已经进行了注册</p><p><img src="https://img-blog.csdnimg.cn/20190811162638700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>注意</strong>：以上方法是最基本的使用方法，SpEL属性的注入中可以引入复杂的算式进行计算注入。</p><h2 id="数组、集合属性的注入"><a href="#数组、集合属性的注入" class="headerlink" title="数组、集合属性的注入"></a>数组、集合属性的注入</h2><p><strong>数组属性注入</strong></p><p>（1）定义一个类中的数组属性，并通过set方法将属性注入</p><p><img src="https://img-blog.csdnimg.cn/20190811162649385.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>（2）配置文件向数组注入多条数据</p><p><img src="https://img-blog.csdnimg.cn/20190811162657167.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>集合属性注入</strong></p><p>一、向list集合注入属性</p><p>（1）类中添加集合定义，并通过使用set方法实现属性注入</p><p><img src="https://img-blog.csdnimg.cn/20190811162706458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>（2）配置文件向list集合添加多条数据</p><p><img src="https://img-blog.csdnimg.cn/20190811162714346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>二、向Map集合注入</p><p>注意配置文件中注入属性的方式</p><p><img src="https://img-blog.csdnimg.cn/20190811162723171.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="Spring的分模块开发"><a href="#Spring的分模块开发" class="headerlink" title="Spring的分模块开发"></a>Spring的分模块开发</h2><p>Spring的分模块开发，这时候会出现多个配置文件，当出现多个配置文件时如何关联多个配置文件？</p><p>方法一</p><p>类工厂的创建时，加载多个配置文件</p><p><img src="https://img-blog.csdnimg.cn/20190811162733620.png" alt="在这里插入图片描述"></p><p>方法二</p><p>在配置文件中关联引入其他的配置文件</p><p><img src="https://img-blog.csdnimg.cn/20190811162740876.png" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;XML提示配置&quot;&gt;&lt;a href=&quot;#XML提示配置&quot; class=&quot;headerlink&quot; title=&quot;XML提示配置&quot;&gt;&lt;/a&gt;XML提示配置&lt;/h1&gt;&lt;p&gt;&lt;str
      
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="Spring笔记" scheme="http://yoursite.com/tags/Spring%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Spring框架-IOC、DI和工厂类的概述</title>
    <link href="http://yoursite.com/2019/08/11/Spring%E6%A1%86%E6%9E%B6-IOC%E5%92%8CDI%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2019/08/11/Spring框架-IOC和DI的区别/</id>
    <published>2019-08-10T18:07:50.286Z</published>
    <updated>2019-08-11T05:30:34.948Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="IOC和DI介绍"><a href="#IOC和DI介绍" class="headerlink" title="IOC和DI介绍"></a>IOC和DI介绍</h1><p>IOC</p><p>控制反转，将对象的创建权反转交给了Spring</p><p>DI:</p><p>依赖注入，前提必须有IOC的环境，Spring管理的这个类的时候将这个类的依赖的属性注入（设置）进来</p><p><strong>存在问题</strong></p><p>IOC 在Spring中的实现方式是通过定义配置文件的方式将需要创建的对象交由Spring来进行管理。但是依然纯在有局限性：父类接口的引用只能实现对父类定义了接口的方法进行调用，对于实现了父类接口的同时又增加了其他的属性，这时候就没办法进行调用了、</p><p><strong>解决办法</strong></p><p>通过使用依赖注入的方式，定义配置文件将对象的依赖属性注入。就可以解决了以上的问题。</p><p>下图为实现类的新属性</p><p><img src="https://img-blog.csdnimg.cn/20190811132639989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>配置文件中实现依赖注入</p><p><img src="https://img-blog.csdnimg.cn/20190811132700678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="Spring工厂类"><a href="#Spring工厂类" class="headerlink" title="Spring工厂类"></a>Spring工厂类</h1><h2 id="Spring工厂类结构图"><a href="#Spring工厂类结构图" class="headerlink" title="Spring工厂类结构图"></a>Spring工厂类结构图</h2><p><img src="https://img-blog.csdnimg.cn/20190811132709675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>（1）老版本工厂类为BeanFactory,新版本的工厂类为ApplicationContext</p><p>（2）ApplicationContext继承了BeanFactory类（子类对象功能更加强大，目前使用的都是新版本的ApplicadtionContext）</p><p>（3）<strong>创建实例的时间上</strong>：BeanFactory在调用getBean()方法的时候才会生成类的实例，ApplicationContext在加载配置文件的时候就会将Spring管理的类全部实例化</p><p>（4）ApplicationContext有两个实现类</p><p>1）ClassPathXmlApplicationContext:</p><p>作用：用来加载类路径下的配置文件（即src目录下的配置文件）</p><p>2)FileSystemXmlApplicationContext</p><p>作用：加载文件系统下的配置文件（即计算机文件系统中的配置文件）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;IOC和DI介绍&quot;&gt;&lt;a href=&quot;#IOC和DI介绍&quot; class=&quot;headerlink&quot; title=&quot;IOC和DI介绍&quot;&gt;&lt;/a&gt;IOC和DI介绍&lt;/h1&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="Spring笔记" scheme="http://yoursite.com/tags/Spring%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Spring框架-概述与IOC入门</title>
    <link href="http://yoursite.com/2019/08/10/Spring%E6%A1%86%E6%9E%B6-%E6%A6%82%E8%BF%B0%E4%B8%8EIOC%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2019/08/10/Spring框架-概述与IOC入门/</id>
    <published>2019-08-09T16:39:18.286Z</published>
    <updated>2019-08-10T07:52:36.778Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="Spring概述"><a href="#Spring概述" class="headerlink" title="Spring概述"></a>Spring概述</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Spring是一个开源框架，spring是于2003年兴起的轻量级java开发框架，由Rod Johnson创建，简单来说是一个分层的JavaSE/EE 一站式轻量级的开源框架。</p><p><strong>轻量级的DI和AOP容器框架</strong></p><p>（1）DI:称作依赖注入(Dependency Injection),和控制反转一个概念，具体的讲，当一个角色需要另外一个角色协助的时候，在传统的程序设计中，通常有调用者来创建被调用者的实例。但是在spring中创建被调用者将不再有调用者完成，因此叫控制反转。创建被调用对象有Spring来完成，在容器实例化对象的时候主动的将被调用者（或者说它的依赖对象）注入给调用对象，因此又叫依赖注入。</p><p>（2）面向切面编程是面向对象编程的有力补充。面向对象编程将程序分成各个层次的对象，面向切面的程序将运行过程分解成各个切面。AOP是从运行程序的角度去考虑程序的结构，提取业务处理过程的切面，OOP是静态的抽象，AOP是动态的抽象，是对应用执行过程的步骤进行抽象，从而获得步骤之间的逻辑划分。</p><p><strong>一站式框架</strong>：有SE/EE开发的每层的解决方案</p><p>（1）WEB层：SpringMVC</p><p>（2）Service层（业务层）： Spring的Bean管理，Spring声明式事务</p><p>（3）DAO层（持久层）：Spring的Jdbc模板，Spring的ORM模块</p><h2 id="Spring优点"><a href="#Spring优点" class="headerlink" title="Spring优点"></a>Spring优点</h2><p>1.使用Spring的IOC容器，将对象之间的依赖关系交给Spring，降低组件之间的耦合性，让我们更专注于应用逻辑</p><p>2.可以提供众多服务，事务管理，WS等。</p><p>3.AOP的很好支持，方便面向切面编程。</p><p>4.对主流的框架提供了很好的集成支持，如Hibernate,Struts2,JPA等</p><p>5.Spring DI机制降低了业务对象替换的复杂性。</p><p>6.Spring属于低侵入，代码污染极低。</p><p>7.Spring的高度可开放性，并不强制依赖于Spring，开发者可以自由选择Spring部分或全部</p><h1 id="Spring入门（IOC）"><a href="#Spring入门（IOC）" class="headerlink" title="Spring入门（IOC）"></a>Spring入门（IOC）</h1><h2 id="IOC概念"><a href="#IOC概念" class="headerlink" title="IOC概念"></a>IOC概念</h2><p>Ioc—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。即将对象的创建权反转（交给）Spring。</p><h2 id="Spring的下载与下载文件的介绍"><a href="#Spring的下载与下载文件的介绍" class="headerlink" title="Spring的下载与下载文件的介绍"></a>Spring的下载与下载文件的介绍</h2><p><strong>下载</strong></p><p>下载地址：<a href="https://repo.spring.io/release/org/springframework/spring/5.1.9.RELEASE/&gt;" target="_blank" rel="noopener">https://repo.spring.io/release/org/springframework/spring/5.1.9.RELEASE/&gt;</a></p><p>或通过本文链接进行下载</p><p>链接：<a href="https://pan.baidu.com/s/1XTyCXmUnlDuRcN6pQp37iQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1XTyCXmUnlDuRcN6pQp37iQ</a><br>提取码：em19 </p><p><strong>目录介绍</strong></p><p>下载解压之后的文件目录</p><p><img src="https://img-blog.csdnimg.cn/20190810154529105.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="eclipse创建WEB项目"><a href="#eclipse创建WEB项目" class="headerlink" title="eclipse创建WEB项目"></a>eclipse创建WEB项目</h2><h3 id="引入jar包"><a href="#引入jar包" class="headerlink" title="引入jar包"></a><strong>引入jar包</strong></h3><h4 id="开发包"><a href="#开发包" class="headerlink" title="开发包"></a>开发包</h4><p>本文主要对Spring的IOC进行讲解,而IOC是Spring体系中的核心容器这块的内容。</p><p>所以将核心容器的jar包导入到工程中即可。</p><p><strong>下图为Spring的体系结构</strong></p><p><img src="https://img-blog.csdnimg.cn/20190810154540981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>核心容器简单介绍：</p><p>1)spring-core：依赖注入IoC与DI的最基本实现</p><p>2)spring-beans：Bean工厂与bean的装配</p><p>3)spring-context：spring的context上下文即IoC容器</p><p>4)spring-expression：spring表达式语言</p><p><strong>如下图所示导入以下jar包</strong></p><p><img src="https://img-blog.csdnimg.cn/20190810154323833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="日志包"><a href="#日志包" class="headerlink" title="日志包"></a>日志包</h4><p>在Spring的开发的过程中是需要日志记录的，所以在进行导包的操作的时候需要导入日志记录的包。在Spring的解压目录里面没有Spring的日志包，需要从<strong>Spring依赖包</strong>中进行寻找添加。</p><p><strong>Spring依赖包下载</strong></p><p>（1）官方下载地址</p><p><a href="http://s3.amazonaws.com/dist.springframework.org/release/SPR/spring-framework-3.0.2.RELEASE-dependencies.zip" target="_blank" rel="noopener">http://s3.amazonaws.com/dist.springframework.org/release/SPR/spring-framework-3.0.2.RELEASE-dependencies.zip</a></p><p>（2）百度云盘下载地址</p><p>链接：<a href="https://pan.baidu.com/s/1hyiK0OuzMh7QvRQCmGpy9A" target="_blank" rel="noopener">https://pan.baidu.com/s/1hyiK0OuzMh7QvRQCmGpy9A</a><br>提取码：4gni </p><p><strong>提醒</strong>：在spring 3.0.2的版本之后就已经不发布spring-framework-3.0.2.RELEASE-dependencies.zip包了。笔者在之前也是网上一顿狂找，浪费了不少的时间。</p><p><strong>添加步骤</strong></p><p>一、添加由apache提供的用于日志记录的接口，里面定义的都是日志接口规范</p><p>（1）在依赖包的目录下打开org.apache.commons/com.springsource.org.apache.commons.logging/1.1.1目录</p><p>（2）选择jar包</p><p><img src="https://img-blog.csdnimg.cn/2019081015431356.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>二、添加具体实现包</p><p>（1）解压目录下org.apache.log4j\com.springsource.org.apache.log4j\1.2.15</p><p>（2）选择jar包</p><p><img src="https://img-blog.csdnimg.cn/20190810154303240.png" alt="在这里插入图片描述"></p><h4 id="导包完成"><a href="#导包完成" class="headerlink" title="导包完成"></a>导包完成</h4><p>至此项目的jar包已经导入完毕，下图是项目中添加包之后的视图</p><p>!<img src="https://img-blog.csdnimg.cn/20190810154345409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="创建接口和类"><a href="#创建接口和类" class="headerlink" title="创建接口和类"></a><strong>创建接口和类</strong></h3><h4 id="（1）传统的开发方式（面向接口的编程）"><a href="#（1）传统的开发方式（面向接口的编程）" class="headerlink" title="（1）传统的开发方式（面向接口的编程）"></a>（1）传统的开发方式（面向接口的编程）</h4><p>在没有Spring之前，传统的开发中通常会伴随着接口与相应的实现类的书写方式出现，这时候的一般开发方式是使用父类接口引用指向子类对象的方法进行（即多态）。如下图所示为传统的开发方式</p><p><img src="https://img-blog.csdnimg.cn/2019081015435363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>传统开发方式存在的不足：</p><p>接口和实现类有耦合（联系过紧）</p><p>如果接口有多个实现类，在项目改变需求的时候，需要进行改变java代码才可以实现功能的改变。</p><p><strong>思考</strong>：如果底层的实现切换了，需要修改源代码，能不能在不修改代码的情况下实现对程序的扩展？</p><p>好的程序设计满足OCP原则，在尽量不修改程序源代码的基础上对程序进行扩展</p><p><strong>工厂模式的出现</strong></p><p>工厂模式中，接口和实现类的调用过程中不新建对象，全部交由工厂进行对象的新建与生产。工厂模式如图所示</p><p><img src="https://img-blog.csdnimg.cn/20190810154401629.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>存在问题：虽然工厂模式解决了接口和实现类之间的耦合问题。但是，如上图所示，在开发过程中如果底层的实现类发生了改变，那么将需要对工厂类中的代码进行修改。这时候接口和实现类已经没有了耦合关系，但是工厂和接口之间存在了耦合的情况。</p><p>程序之间耦合解决方法：工厂模式+反射+配置文件，如图所示。在实现类发生变化的时候只需要修改配置文件即可实现对程序的扩展。（其实这就是Spring IOC的底层实现）</p><p><img src="https://img-blog.csdnimg.cn/20190810154413100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="（2）Spring开发方式"><a href="#（2）Spring开发方式" class="headerlink" title="（2）Spring开发方式"></a>（2）Spring开发方式</h4><p>1）在src目录下新建配置文件：applicationContext.xml(xml格式文件，名字可以随便取，该处为默认的配置文件名)</p><p>2）引入配置文件约束</p><p> 在使用spring的配置文件时,新添加一个配置文件就需要添加相应的约束。原因是spring在启动的时候需要验证xml文档,约束的作用就是来验证配置文件的xml文档语法的正确性。</p><p><strong>加入方式</strong></p><p>目录：spring-framework-5.1.9.RELEASE\docs\spring-framework-reference</p><p>打开目录下的core.html文件，通过快捷键撒的方式对文件进行检索The Beans Schema关键词，并复制如下图所示代码到配置文件中去</p><p><img src="https://img-blog.csdnimg.cn/2019081015442510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>3）编写配置文件，并在测试文件中将接口的实现类进行定义，将其交由Spring进行管理，如图所示</p><p><img src="https://img-blog.csdnimg.cn/20190810154457572.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>4）创建日志文件</p><p>在src的目录下创建名为log4j.propertiesj配置文件，配置log4j输出的类型，记录的位置，日志的编码格式等等。创建完成后，添加如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">### direct log messages to stdout ###</span><br><span class="line">log4j.appender.stdout=org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.stdout.Target=System.err</span><br><span class="line">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern=%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n</span><br><span class="line"></span><br><span class="line">### direct messages to file mylog.log ###</span><br><span class="line">log4j.appender.file=org.apache.log4j.FileAppender</span><br><span class="line">log4j.appender.file.File=c\:mylog.log</span><br><span class="line">log4j.appender.file.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.file.layout.ConversionPattern=%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n</span><br><span class="line"></span><br><span class="line">### set log levels - for more verbose logging change &apos;info&apos; to &apos;debug&apos; ###</span><br><span class="line"># error warn info debug trace</span><br><span class="line">log4j.rootLogger= info, stdout</span><br></pre></td></tr></table></figure><p>5）编写测试类进行测试</p><p><img src="https://img-blog.csdnimg.cn/2019081015450873.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;Spring概述&quot;&gt;&lt;a href=&quot;#Spring概述&quot; class=&quot;headerlink&quot; title=&quot;Spring概述&quot;&gt;&lt;/a&gt;Spring概述&lt;/h1&gt;&lt;h2
      
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="Spring笔记" scheme="http://yoursite.com/tags/Spring%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Linux实操篇-PRM与YUM</title>
    <link href="http://yoursite.com/2019/06/01/Linux%E5%AE%9E%E6%93%8D%E7%AF%87-PRM%E4%B8%8EYUM/"/>
    <id>http://yoursite.com/2019/06/01/Linux实操篇-PRM与YUM/</id>
    <published>2019-06-01T06:20:16.540Z</published>
    <updated>2019-07-21T10:55:44.515Z</updated>
    
    <content type="html"><![CDATA[<p><meta name="referrer" content="no-referrer"></p><h1 id="RPM包的管理"><a href="#RPM包的管理" class="headerlink" title="RPM包的管理"></a>RPM包的管理</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>一种用于互联网下载包的打包及安装工具，它包含在某些Linux分发版中。它生成 具有.RPM扩展名的文件。RPM是RedHat Package Manager（RedHat软件包管理工 具）的缩写，类似windows的setup.exe，这一文件格式名称虽然打上了RedHat的 标志，但理念是通用的。<br>Linux的分发版本都有采用（suse,redhat, centos 等等），可以算是公认的行业标 准了。</p><h2 id="rpm包的简单查询指令"><a href="#rpm包的简单查询指令" class="headerlink" title="rpm包的简单查询指令"></a>rpm包的简单查询指令</h2><p>查询已安装的rpm列表 rpm  –qa|grep xx</p><p><strong>实例</strong></p><p>（1）查看当前的系统有没有安装有火狐浏览器</p><p><img src="https://img-blog.csdnimg.cn/20190601140550746.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" width="55%" height="55%" alt="图片名称" align="center"></p><p><strong>rpm包名基本格式：</strong></p><p>一个rpm包名：firefox-45.0.1-1.el6.centos.x86_64.rpm </p><p>名称:firefox </p><p>版本号：60.7.0-1 </p><p>适用操作系统: el6.centos.x86_64 表示centos6.x的64位系统</p><p> 如果是i686、i386表示32位系统，noarch表示通用。</p><p><strong>rpm包的其它查询指令：</strong><br>(1)rpm -qa :查询所安装的所有rpm软件包</p><p>   rpm -qa | more  </p><p><img src="//img-blog.csdnimg.cn/20190601140911227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" width="55%" height="55%" alt="图片名称" align="center"></p><p>  rpm -qa | grep X [rpm -qa | grep firefox ]</p><p>(2)rpm -q 软件包名 :查询软件包是否安装 </p><p>  rpm -q firefox</p><p><img src="https://img-blog.csdnimg.cn/20190601140852822.png" width="55%" height="55%" alt="图片名称" align="center"></p><p>(3)rpm -qi 软件包名 ：查询软件包信息 </p><p>  rpm -qi file</p><p><img src="https://img-blog.csdnimg.cn/20190601140627504.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" width="55%" height="55%" alt="图片名称" align="center"></p><p>(4)rpm -ql 软件包名 :查询软件包中的文件 </p><p>  rpm -ql firefox</p><p><img src="https://img-blog.csdnimg.cn/20190601140600899.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" width="55%" height="55%" alt="图片名称" align="center"></p><p>(5)rpm -qf 文件全路径名 查询文件所属的软件包 </p><p>  rpm -qf /etc/passwd </p><p><img src="https://img-blog.csdnimg.cn/20190601140615829.png" width="55%" height="55%" alt="图片名称" align="center"></p><h2 id="卸载rpm包"><a href="#卸载rpm包" class="headerlink" title="卸载rpm包"></a>卸载rpm包</h2><p> 基本语法 rpm -e RPM包的名称 </p><p> 应用案例</p><p> 1) 删除firefox  软件包 </p><p><img src="https://img-blog.csdnimg.cn/20190601140755609.png" width="55%" height="55%" alt="图片名称" align="center"></p><p> <strong>细节说明</strong> </p><p>1) 如果其它软件包依赖于您要卸载的软件包，卸载时则会产生错误信息。</p><p> 如： $ rpm -e foo removing these packages would break dependencies:foo is needed by bar-1.0-1</p><p> 2) 如果我们就是要删除 foo这个rpm 包，可以增加参数 –nodeps ,就可以强制删除，但是一 般不推荐这样做，因为依赖于该软件包的程序可能无法运行</p><p> 如：$ rpm -e –nodeps foo </p><h2 id="安装rpm包"><a href="#安装rpm包" class="headerlink" title="安装rpm包"></a>安装rpm包</h2><p> 基本语法 rpm -ivh  RPM包全路径名称 </p><p> 参数说明</p><p> i=install 安装 </p><p>v=verbose 提示</p><p> h=hash  进度条</p><p><strong>实例</strong><br>1) 演示安装firefox浏览器</p><p>步骤：</p><p>1）先找到firefox 的rpm安装包，需要挂载系统的ios文件，然后去/media/找到rpm安装包</p><p>2）找到之后，使用cp 指令将安装包拷贝到/opt/目录下</p><p>3）进入到opt目录下安装</p><p><img src="https://img-blog.csdnimg.cn/20190601140808597.png" width="55%" height="55%" alt="图片名称" align="center"></p><h1 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p> Yum 是一个Shell前端软件包管理器。基于RPM包管理，能够从指定 的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并 且一次安装所有依赖的软件包。</p><p><img src="https://img-blog.csdnimg.cn/20190601140815567.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" width="55%" height="55%" alt="图片名称" align="center"></p><h2 id="yum的基本指令"><a href="#yum的基本指令" class="headerlink" title="yum的基本指令"></a>yum的基本指令</h2><p>查询yum服务器是否有需要安装的软件 yum list|grep xx软件列表</p><p>安装指定的yum包: yum install xxx  下载安装<br><strong>实例</strong><br>(1)请使用yum的方式来安装firefox</p><p>步骤：</p><p>1）先查看yum服务器有没有这个软件的安装包</p><p><img src="https://img-blog.csdnimg.cn/20190601140822651.png" width="55%" height="55%" alt="图片名称" align="center"></p><p>2）安装</p><p><img src="https://img-blog.csdnimg.cn/20190601140830579.png" width="55%" height="55%" alt="图片名称" align="center"></p><p>会安装最新版的软件</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;RPM包的管理&quot;&gt;&lt;a href=&quot;#RPM包的管理&quot; class=&quot;headerlink&quot; title=&quot;RPM包的管理&quot;&gt;&lt;/a&gt;RPM包的管理&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux实操" scheme="http://yoursite.com/tags/Linux%E5%AE%9E%E6%93%8D/"/>
    
  </entry>
  
  <entry>
    <title>Linux实操篇-进程管理</title>
    <link href="http://yoursite.com/2019/06/01/Linux%E5%AE%9E%E6%93%8D%E7%AF%87-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2019/06/01/Linux实操篇-进程管理/</id>
    <published>2019-06-01T03:48:10.260Z</published>
    <updated>2019-07-21T10:56:15.591Z</updated>
    
    <content type="html"><![CDATA[<p><meta name="referrer" content="no-referrer"></p><h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><p>1) 在LINUX中，每个执行的程序（代码）都称为一个进程。每一个进程都分配一 个ID号。</p><p> 2) 每一个进程，都会对应一个父进程，而这个父进程可以复制多个子进程。例 如www服务器。</p><p>3) 每个进程都可能以两种方式存在的。前台与后台，所谓前台进程就是用户目 前的屏幕上可以进行操作的。后台进程则是实际在操作，但由于屏幕上无法 看到的进程，通常使用后台方式执行。 </p><p>4) 一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中。直到 关机才才结束。</p><h1 id="显示系统执行的进程"><a href="#显示系统执行的进程" class="headerlink" title="显示系统执行的进程"></a>显示系统执行的进程</h1><h2 id="ps指令"><a href="#ps指令" class="headerlink" title="ps指令"></a>ps指令</h2><p>基本介绍： ps命令是用来查看目前系统中，有哪些正在执行，以及它们执行的状况。 可以不加任何参数.</p><p>说明：查看进程使用的指令是ps，一般来说使用的参数是ps -aux</p><p>ps显示的信息选项</p><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>PID</td><td>进程识别号</td></tr><tr><td>TTY</td><td>终端机号</td></tr><tr><td>TIME</td><td>此进程所消cpu时间</td></tr><tr><td>CMD</td><td>正在执行的命令或进程名</td></tr></tbody></table><p>常见命令与说明</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>ps -a</td><td>显示当前终端的所有进程信息</td></tr><tr><td>ps -u</td><td>以用户格式显示进程信息</td></tr><tr><td>ps  -x</td><td>显示后台进程运行的参数</td></tr></tbody></table><p><strong>实例</strong></p><p><img src="https://img-blog.csdnimg.cn/20190601113234578.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="ps详解"><a href="#ps详解" class="headerlink" title="ps详解"></a>ps详解</h2><p>1) 指令：ps –aux|grep xxx ，比如我看看有没有sshd服务 </p><p>2) 指令说明 </p><p>• System V展示风格</p><p> • USER：用户名称 </p><p>• PID：进程号 </p><p><strong>• %CPU：进程占用CPU的百分比</strong></p><p> <strong>• %MEM：进程占用物理内存的百分比</strong></p><p> <strong>• VSZ：进程占用的虚拟内存大小（单位：KB）</strong></p><p> <strong>• RSS：进程占用的物理内存大小（单位：KB）</strong></p><p> • TT：终端名称,缩写 .</p><p> • STAT：进程状态，其中S-睡眠，s-表示该进程是会话的先导进程，N-表示进程拥有比普通 优先级更低的优先级，R-正在运行，D-短期等待，Z-僵死进程，T-被跟踪或者被停止等等 </p><p>• STARTED：进程的启动时间</p><p> • TIME：CPU时间，即进程使用CPU的总时间 • COMMAND：启动进程所用的命令和参数，如果过长会被截断显示</p><h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><p>要求：以全格式显示当前所有的进程，查看进程的父进程。</p><p>（1）ps -ef是以全格式显示当前所有的进程 • -e 显示所有进程。-f 全格式。 </p><p>（2） ps -ef | grep xxx </p><p><img src="https://img-blog.csdnimg.cn/2019060111330952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>详解：</p><p>​     1） 是BSD风格 </p><p>​     2） UID：用户ID</p><p>​     3） PID：进程ID </p><p>​     4） PPID：父进程ID</p><p>​     5） C：CPU用于计算执行优先级的因子。数值越大，表明进程是CPU密集型运  算， 执行优先级会降低；数值越小，表明进程是I/O密集型运算，执行优先级会提高</p><p>​      6） STIME：进程启动的时间</p><p>​      7） TTY：完整的终端名称 • TIME：CPU时间 • CMD：启动进程所用的命令和参数</p><h1 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h1><h2 id="终止进程kill和killall"><a href="#终止进程kill和killall" class="headerlink" title="终止进程kill和killall"></a>终止进程kill和killall</h2><p>介绍: 若是某个进程执行一半需要停止时，或是已消了很大的系统资源时，此时可以考虑停止该 进程。使用kill命令来完成此项任务。 </p><p>基本语法： </p><p>1）kill  [选项] 进程号（功能描述：通过进程号杀死进程）</p><p>2） killall 进程名称 （功能描述：通过进程名称杀死进程，也支持通配符，这在系统因负 载过大而变得很慢时很有用）</p><p>常用选项： -9 :表示强迫进程立即停止 </p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>（1）踢掉某个非法登录用户</p><p><img src="https://img-blog.csdnimg.cn/20190601113349466.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>（2）终止远程登录服务sshd，在适当的时候再重启sshd服务</p><p><img src="https://img-blog.csdnimg.cn/20190601113411979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>（3）终止多个gedit编辑器【killall】</p><p><img src="https://img-blog.csdnimg.cn/20190601113425467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>特别说明：如果使用该指令杀掉某些进行的父进程，那么相对应的子进程也会被杀掉</p><p>（4）强制杀掉一个终端</p><p><img src="https://img-blog.csdnimg.cn/20190601113436475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="查看进程树"><a href="#查看进程树" class="headerlink" title="查看进程树"></a>查看进程树</h1><p>基本语法： pstree [选项] ,可以更加直观的来看进程信息<br>常用选项： -p :显示进程的PID -u :显示进程的所属用户 </p><p><strong>实例</strong> </p><p>请你树状的形式显示进程的pid </p><p><img src="https://img-blog.csdnimg.cn/20190601113453876.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="服务（service）管理"><a href="#服务（service）管理" class="headerlink" title="服务（service）管理"></a>服务（service）管理</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>服务(service) 本质就是进程，但是是运行在后台的，通常都会监听某个端口，等待其它程 序的请求，比如(mysql , sshd  防火墙等)，因此我们又称为守护进程，是Linux中非常重要的 知识点。</p><p>【原理图】</p><p><img src="https://img-blog.csdnimg.cn/20190601113527202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="service管理指令"><a href="#service管理指令" class="headerlink" title="service管理指令"></a>service管理指令</h2><p> service  服务名 [start | stop | restart | reload | status] </p><p>在CentOS7.0后 不再使用service ,而是 systemctl </p><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p> 1) 查看当前防火墙的状况，关闭防火墙和重启防火墙。</p><p>防火墙当前状态</p><p><img src="https://img-blog.csdnimg.cn/20190601113534621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="这里插入图片描述"></p><p>关闭和重启防火墙</p><p><img src="https://img-blog.csdnimg.cn/20190601113542466.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="细节说明"><a href="#细节说明" class="headerlink" title="细节说明"></a>细节说明</h2><p>1) 关闭或者启用防火墙后，立即生效。[telnet 测试 某个端口即可] </p><p>windows的dos命令行下测试服务器指定端口</p><p><img src="https://img-blog.csdnimg.cn/20190601113553768.png" alt="在这里插入图片描述"></p><p>2) 这种方式只是临时生效，当重启系统后，还是回归以前对服务的设置。</p><p>3) 如果希望设置某个服务自启动或关闭永久生效，要使用chkconfig指令</p><h2 id="查看服务名"><a href="#查看服务名" class="headerlink" title="查看服务名"></a>查看服务名</h2><p>方式1：使用setup -&gt; 系统服务 就可以看到。 </p><p>（特别说明：系统界面退出只需要点击Tab键切换选择到确认取消按钮，再点击enter即可选择按下，进而退出页面）</p><p><img src="https://img-blog.csdnimg.cn/20190601113602837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>方式2:   /etc/init.d/服务名称</p><p><img src="https://img-blog.csdnimg.cn/20190601113615609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="运行级别"><a href="#运行级别" class="headerlink" title="运行级别"></a>运行级别</h2><p>（1）服务的运行级别(runlevel)，服务在Linux的各个运行级别中均可修改是否自启动</p><p>（2） 查看或者修改默认级别：vi /etc/inittab</p><p> （3）Linux系统有7种运行级别(runlevel)：常用的是级别3和5 </p><p>• 运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动 </p><p>• 运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登陆 </p><p>• 运行级别2：多用户状态(没有NFS)，不支持网络 </p><p>• 运行级别3：完全的多用户状态(有NFS)，登陆后进入控制台命令行模式</p><p> • 运行级别4：系统未使用，保留 </p><p>• 运行级别5：X11控制台，登陆后进入图形GUI模式</p><p> • 运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动 </p><p><strong>开机的流程说明</strong></p><p><img src="https://img-blog.csdnimg.cn/20190601113626410.png" alt="在这里插入图片描述"></p><h3 id="chkconfig指令"><a href="#chkconfig指令" class="headerlink" title="chkconfig指令"></a>chkconfig指令</h3><p>介绍 通过chkconfig 命令可以给每个服务的各个运行级别设置自启动/关闭</p><p>  基本语法</p><p> 1) 查看服务 chkconfig –list|grep  xxx  </p><p><img src="https://img-blog.csdnimg.cn/20190601113647513.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20190601113654372.png" alt="这里插入图片描述"></p><p>2) chkconfig   服务名 –list </p><p><img src="/.com//桌面\Snipaste_2019-06-01_10-47-48.png" alt="Snipaste_2019-06-01_10-47-48"></p><p>3)  chkconfig   –level  5   服务名 on/off </p><p>需求：请将sshd在运行级别为5的情况下，不要自启动</p><p><img src="https://img-blog.csdnimg.cn/20190601113732576.png" alt="在这里插入图片描述"></p><p><strong>实例</strong></p><p>1)  请显示当前系统所有服务的各个运行级别的运行状态</p><p><img src="https://img-blog.csdnimg.cn/20190601113743968.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>2) 请查看sshd服务的运行状态 </p><p><img src="https://img-blog.csdnimg.cn/20190601113759664.png" alt="在这里插入图片描述"></p><p>3)  将sshd 服务在运行级别5下设置为不自动启动，看看有什么效果？ </p><p>指令：chkconfig –level 5 sshd off</p><p>4)  当运行级别为5时，关闭防火墙。</p><p>指令：chkconfig –level 5 iptables off</p><p>5) 在所有运行级别下，关闭防火墙</p><p>指令：chkconfig iptables off</p><p>6) 在所有运行级别下，开启防火墙</p><p>指令： chkconfig iptables on</p><p><strong>细节说明</strong>：chkconfig重新设置服务自启动或关闭后，需要重新启动机器reboot才能生效</p><h1 id="监控服务"><a href="#监控服务" class="headerlink" title="监控服务"></a>监控服务</h1><h2 id="动态监控进程"><a href="#动态监控进程" class="headerlink" title="动态监控进程"></a>动态监控进程</h2><p>介绍</p><p>top与ps命令很相似。它们都用来显示正在执行的进程。top与ps最大的不同之处，在于top 在执行一段时间可以更新正在运行的的进程。</p><p>基本语法： top [选项]</p><p><img src="https://img-blog.csdnimg.cn/20190601113808901.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>选项说明：</strong></p><table><thead><tr><th style="text-align:left">选项</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:left">-d 秒数</td><td style="text-align:left">指定top命令每隔几秒更新。默认是3秒在top命令的交互模式当中可以执行的 命令：</td></tr><tr><td style="text-align:left">-i</td><td style="text-align:left">使top不显示任何闲置或者僵死进程。</td></tr><tr><td style="text-align:left">-p</td><td style="text-align:left">通过指定监控进程ID来仅仅监控某个进程的状态。</td></tr></tbody></table><p><strong>交互操作说明：</strong></p><table><thead><tr><th>操作</th><th>功能</th></tr></thead><tbody><tr><td>P</td><td>以CPU使用率排序，默认就是此项</td></tr><tr><td>M</td><td>以内存的使用率排序</td></tr><tr><td>N</td><td>以PID排序</td></tr><tr><td>q</td><td>退出top</td></tr></tbody></table><p><strong>实例</strong></p><p>（1）监视特定用户</p><p> 步骤：</p><p>1）top：输入此命令，按回车键，查看执行的进程。 </p><p>2）u：然后输入“u”回车，再输入用户名，即可</p><p>（2）终止指定的进程。</p><p>步骤：</p><p> 1）top：输入此命令，按回车键，查看执行的进程。</p><p> 2） k：然后输入“k”回车，再输入要结束的进程ID号</p><p><img src="https://img-blog.csdnimg.cn/20190601113848444.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p> （3）指定系统状态更新的时间(每隔10秒自动更新，默认是3秒)：</p><p>指令：top -d 10</p><h2 id="监控网络状态"><a href="#监控网络状态" class="headerlink" title="监控网络状态"></a>监控网络状态</h2><p>查看系统网络情况netstat<br>基本语法 ：netstat [选项] </p><p>常用指令：netsat -anp</p><p>选项说明</p><p>1）-an  按一定顺序排列输出 </p><p>2）-p  显示哪个进程在调用 </p><p><strong>实例</strong></p><p>(1)查看系统所有的网络服务</p><p><img src="https://img-blog.csdnimg.cn/20190601113856500.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p> (2)请查看服务名为 sshd 的服务的信息。</p><p><img src="https://img-blog.csdnimg.cn/20190601113903208.png" alt="在这里插入图片描述"></p><p>检测主机连接命令ping： 是一种网络检测检测工具，它主要是用检测远程主机是否正常，或是两部主机间 的介质是否为断、网线是否脱落或网卡故障。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h1&gt;&lt;p&gt;1) 在LINUX中
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux实操" scheme="http://yoursite.com/tags/Linux%E5%AE%9E%E6%93%8D/"/>
    
  </entry>
  
  <entry>
    <title>Java基础篇-多线程</title>
    <link href="http://yoursite.com/2019/05/31/Java%E5%9F%BA%E7%A1%80%E7%AF%87-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/05/31/Java基础篇-多线程/</id>
    <published>2019-05-31T07:16:00.529Z</published>
    <updated>2019-08-09T14:48:18.844Z</updated>
    
    <content type="html"><![CDATA[<p><meta name="referrer" content="no-referrer"></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p><strong>进程</strong>：是一个正在执行中的程序。</p><p>说明：每一个进程执行都有一个执行顺序。该顺序是一个执行路径，或者叫一个控制单元</p><p><strong>线程</strong>：就是进程中的一个独立的控制单元。</p><p>说明：线程在控制着进程的执行</p><p><strong>细节说明</strong>：一个进程中至少有一个线程</p><h2 id="Java中的线程与进程"><a href="#Java中的线程与进程" class="headerlink" title="Java中的线程与进程"></a>Java中的线程与进程</h2><p>Java VM 在启动的时候会有一个java.exe</p><p>该进程中至少一个线程负责java程序的执行，而且这个线程运行的代码存在于main方法中，该线程称之为主线程</p><p><strong>扩展知识</strong>：其实更细节说明jvm，jvm启动不止一个线程，还有负责垃圾回收机制的线程。所以至少两个线程</p><h1 id="创建线程-继承Thread类"><a href="#创建线程-继承Thread类" class="headerlink" title="创建线程-继承Thread类"></a>创建线程-继承Thread类</h1><p>java已经提供了对线程这类事物的描述。就是Thread类。</p><p>1）创建线程的第一种方式：继承Thread类，并覆盖run方法</p><p>2）创建线程的第二种方式：声明实现Runable接口的类，该类然后实现run方法</p><h2 id="第一种方式创建线程"><a href="#第一种方式创建线程" class="headerlink" title="第一种方式创建线程"></a>第一种方式创建线程</h2><p>覆盖run方法的原因</p><p>（1）Thread类用于描述线程。该类定义了一个功能，用于存储线程中要运行的代码。该存储功能就是run方法</p><p>（2）Thread类中的run方法用于存储线程中要运行的代码</p><p>步骤：</p><p>1）定义类继承Thread方法</p><p>2）复写Thread类中的run方法</p><p>3）调用线程的start方法，启动线程以及调用run（）方法</p><p>实例：</p><p><img src="https://img-blog.csdnimg.cn/20190809223636256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>细节说明：</p><p>(1)发现运行结果每一次的都不同，因为多个线程都在获取cpu的执行权。cpu执行到谁，谁就运行。</p><p>(2)cpu在做着快速的切换，以达到看上去同时运行的效果。</p><p>(3)我们可以形象的把多线程的运行认为在相互抢夺cpu的执行权。这就是多线程的特性：随机性,谁抢到谁执行，至于执行多长时间，cpu说了算</p><p>明确一点：在某一时刻，只能有一个程序运行。（多核除外）</p><h2 id="第二种方式创建线程"><a href="#第二种方式创建线程" class="headerlink" title="第二种方式创建线程"></a>第二种方式创建线程</h2><p>步骤：</p><p>1）定义类实现Runable接口</p><p>2）覆盖Runablez接口中的run方法</p><p>​      将线程中要运行的代码存放在该run方法中</p><p>3）通过Thread类建立线程对象</p><p>4）将Runable接口的子类对象作为实际参数传递给Thread类的构造函数</p><p>​       为什么要将Runable接口子类对象传递给Thread的构造函数？因为，自定义的run方法所属的对象是Runable接口的子类对象。所以要让线程去执行指定对象的run方法，就必须明确该run方法所属的对象</p><p>5）调用Thread类中的start方法开启线程并调用Runable接口子类的run方法</p><p>实例</p><p><img src="https://img-blog.csdnimg.cn/20190809223707723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="方式1和方式2的区别"><a href="#方式1和方式2的区别" class="headerlink" title="方式1和方式2的区别"></a>方式1和方式2的区别</h2><p>1）方式2 避免了单继承的局限性，在定义线程时，建议使用实现方式（方式2）</p><p>2）继承Thread:线程代码存放在Thread子类的run方法中,实现Runable接口线程代码存放在接口子类的run方法中</p><h1 id="线程的四种状态"><a href="#线程的四种状态" class="headerlink" title="线程的四种状态"></a>线程的四种状态</h1><p><img src="https://img-blog.csdnimg.cn/20190809224117842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>（1）线程在运行的时候会建立线程池，等待的线程都在线程池中。</p><p>（2）notify()方法唤醒的通常是线程池中等待的第一个等待线程</p><p>（3）它们都是使用在同步中，因为要对持有监视器也就是锁的线程进行操作，所以要使用在同步中。</p><p> （4）wait();notify();notifyAll();定义在Object类中的原因是：</p><p>  1）这些方法在操作同步线程的时候，都必须要对它们所标记到的线程只有的锁，只有同一个锁上的被等待线程，可以被同一个锁上的线程的notify()方法唤醒。不可以对不同锁中的线程进行唤醒。<strong>也就是说等待和唤醒都必须是同一锁</strong></p><p> 2）因为锁（监视器）是任意的对象，所以可以被任意对象调用的方法定义在Object中</p><h1 id="线程对象与线程名称"><a href="#线程对象与线程名称" class="headerlink" title="线程对象与线程名称"></a>线程对象与线程名称</h1><h2 id="获取默认线程名称"><a href="#获取默认线程名称" class="headerlink" title="获取默认线程名称"></a>获取默认线程名称</h2><p>线程都有自己的默认的名称</p><p>默认名称：Thread-编号 （编号从0开始）</p><p>获取线程名称方法：使用getName()方法。</p><p><strong>实例</strong></p><p><img src="https://img-blog.csdnimg.cn/20190809223733733.png" alt="在这里插入图片描述"></p><h2 id="自定义线程名称"><a href="#自定义线程名称" class="headerlink" title="自定义线程名称"></a>自定义线程名称</h2><p>自定义线程名称有两种方式进行设置：</p><p>1）使用setName()方法进行设置</p><p>2）构造函数方式进行设置</p><p><strong>获取线程对象：</strong></p><p>static Thread currentThread()；获取当前线程的对象</p><p><strong>自定义线程名称步骤如下：</strong></p><p>1）创建线程即初始化时，向线程对象传递线程名称</p><p>2）线程类中书写构造函数，并使用父类构造方法</p><p><strong>实例</strong></p><p>自定义线程名称，并在运行时显示自定义线程名称到控制台中</p><p>1）通过调用currentThread()方法获取当前线程的对象</p><p>2）线程对象调用线程的getName（）方法，获取当前线程的名称</p><p><img src="https://img-blog.csdnimg.cn/20190809224159774.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="多线程的安全性问题"><a href="#多线程的安全性问题" class="headerlink" title="多线程的安全性问题"></a>多线程的安全性问题</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>当多条语句在操作同一个线程共享数据时，一个线程对多条语句只执行了一部分，还没有执行完，另外一个线程参与进来导致了共享数据出现错误</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>对多条操作共享数据的语句，只能让一个线程都执行完才能执行其他线程。在执行的过程中不允许其他线程的参与执行。</p><p>（1）Java对于多线程的安全问题提供了专业的解决方式——同步代码块</p><p><img src="https://img-blog.csdnimg.cn/20190809224231162.png" alt="在这里插入图片描述"></p><p>注意：对象如同锁。持有锁的线程可以在同步中执行。没有持有锁的线程即使获取cpu的执行权，也进不去，因为没有锁。</p><p>（2）同步函数</p><p>同步函数：函数是线程安全的，在函数的定义时在返回值的前面加上synchronized关键字修饰，使得其为同步函数。如下图所示</p><p><img src="https://img-blog.csdnimg.cn/20190809223806984.png" alt="在这里插入图片描述"></p><p>注意：同步函数的锁。因为函数是要被一个对象调用的，所以函数都有一个所属对象应用，它的同步锁就是this</p><p>（3）静态同步函数</p><p>如果同步函数被静态修饰以后，使用的同步锁不是this（为什么？）因为静态函数在类被加载的时候虚拟机就会自动去加载静态修饰的方法或变量部分。所以它的同步锁不会是this。那它的同步锁是什么？因为静态进内存时，内存中没有该类对象在内存中，但是一定有该类对应的字节码文件对象。</p><p>锁：静态同步方法所在类的字节码文件。类名.class</p><h2 id="同步的前提"><a href="#同步的前提" class="headerlink" title="同步的前提"></a>同步的前提</h2><p>（1）必须要有两个或者两个以上的线程</p><p>（2）必须是多个线程使用同一个锁</p><h2 id="好处和弊端"><a href="#好处和弊端" class="headerlink" title="好处和弊端"></a>好处和弊端</h2><p>好处：解决了多线程的安全问题</p><p>弊端：多个线程需要判断锁，较为耗费资源</p><h1 id="单例设计模式（懒汉式）"><a href="#单例设计模式（懒汉式）" class="headerlink" title="单例设计模式（懒汉式）"></a>单例设计模式（懒汉式）</h1><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>（1）单例设计模式中饿汉式设计模式，代码回顾示意图</p><p><img src="https://img-blog.csdnimg.cn/20190809223855268.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>（2）单例设计模式中懒汉设计模式（延迟加载）</p><p><img src="https://img-blog.csdnimg.cn/20190809223910801.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="单例设计模式-懒汉式模式带来的线程安全问题的考虑"><a href="#单例设计模式-懒汉式模式带来的线程安全问题的考虑" class="headerlink" title="单例设计模式-懒汉式模式带来的线程安全问题的考虑"></a>单例设计模式-懒汉式模式带来的线程安全问题的考虑</h2><p>（1）问题：当多个线程通过单例设计模式（懒汉式），获取对象时，由于没有同步函数或同步代码块。又存在共享的返回数据，于是这样就造成了线程的不安全</p><p>（2）解决办法</p><p><img src="https://img-blog.csdnimg.cn/20190809223933506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>注意：采用双判断的方式，提高了程序运行的工作效率。避免在程序运行过程中出现不停进入到同步代码块中进行没必要的判断，并消耗cpu资源</p><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>在程序设计的过程中，出现同步嵌套。如：同步函数中嵌套有同步代码块，当他们的锁不一样时。就会出现挂起的现象。原因是一个锁只能为一个线程解锁。在多个线程出现需要该锁进行解锁的时候就会导致相互抢夺的情况。</p><h1 id="JDK1-5新特性"><a href="#JDK1-5新特性" class="headerlink" title="JDK1.5新特性"></a>JDK1.5新特性</h1><p>在JDK1.5中提供了多线程升级的解决方案。将同步synchornized替换成Lock操作。将Object中的wait,notify,notifyAll,替换成了Condition对象。该对象可以对Lock锁进行获取。</p><p><strong>实例</strong></p><p>生产者和消费者（生产一个消费一个）</p><p><img src="https://img-blog.csdnimg.cn/20190809223949936.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>注意：该实例中，实现了本方只唤醒对方的操作</p><p><strong>总结</strong> 1.5版本以后提供了显示的锁机制以及显示的锁对象的等待唤醒机制。同时把锁进行了封装，实现了一个锁对应多个Condition对象。</p><h1 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h1><h2 id="停止线程的方法"><a href="#停止线程的方法" class="headerlink" title="停止线程的方法"></a>停止线程的方法</h2><p>（1）stop方法已经过时</p><p>（2）只能让run方法结束</p><p>开启多线程运行，运行代码通常是循环结构的，只要控制住循环，就可以让run方法结束，也就是线程结束。<strong>在循环结构中定义标志位对标志位进行控制实现对线程的控制</strong></p><h2 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h2><p>当线程处于冻结状态，就不会读取到标记，那么线程就不会结束。</p><p>\当没有指定方式让冻结的线程恢复到运行状态时，这时候需要对冻结进行清除。强制让线程恢复到运行状态中来，这样就可以操作标记让线程结束。</p><p>Tread类中提供录入该方法interrupt();</p><h1 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h1><p>将线程标记为用户线程或守护线程。当正在运行的线程都是守护线程时，java虚拟机自动退出，也就是主线程结束的时候虚拟机也跟着结束。</p><p>启动线程前调用setDaemon()方法传入true，将线程标记为守护线程</p><p><strong>实例</strong></p><p><img src="https://img-blog.csdnimg.cn/20190809224002244.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h1><p>当A线程执行到了B线程的.join方法时，A就会等待。等B线程都执行完，A才会执行。join可以用来临时加入线程执行。</p><p>实例：通过调用线程的join方法实现主线程的暂停操作，对调用了join方法的线程执行完毕结束之后，主线程才被重新唤醒</p><p><img src="https://img-blog.csdnimg.cn/20190809224012279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="线程优先级和yield方法"><a href="#线程优先级和yield方法" class="headerlink" title="线程优先级和yield方法"></a>线程优先级和yield方法</h1><h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><p>在多线程中，java线程具有的线程优先级越高其获得的执行次数就越多。Java线程中总共有十级的优先级。默认的优先级是5。</p><p>设置优先级的办法：调用 setPriority();方法，传入线程优先级参数。</p><p>为了程序的阅读性，在Java中将优先级1,5,10定义了静态字段在Thread类中。分别是MIN_PRIORITY、NORM_PRIORITY、MAX_PRIORITY</p><p><strong>实例</strong></p><p><img src="https://img-blog.csdnimg.cn/20190809224021802.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="yield方法"><a href="#yield方法" class="headerlink" title="yield方法"></a>yield方法</h2><p>减缓线程执行的频率，将线程的执行权交给其他线程进行执行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;h2 id=&quot;进程与线程&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Linux实操篇-网络配置</title>
    <link href="http://yoursite.com/2019/05/31/Linux%E5%AE%9E%E6%93%8D%E7%AF%87-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/05/31/Linux实操篇-网络配置/</id>
    <published>2019-05-31T06:40:26.545Z</published>
    <updated>2019-07-21T10:56:24.365Z</updated>
    
    <content type="html"><![CDATA[<p><meta name="referrer" content="no-referrer"></p><h1 id="虚拟机网络模式"><a href="#虚拟机网络模式" class="headerlink" title="虚拟机网络模式"></a>虚拟机网络模式</h1><p>1）虚拟机连接网络的三种模式</p><p><img src="https://img-blog.csdnimg.cn/2019053114331367.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>2）虚拟机使用NAT模式的网络原理图<img src="https://img-blog.csdnimg.cn/20190531143255441.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="查看网络IP和网关"><a href="#查看网络IP和网关" class="headerlink" title="查看网络IP和网关"></a>查看网络IP和网关</h1><h2 id="查看虚拟网络编辑器"><a href="#查看虚拟网络编辑器" class="headerlink" title="查看虚拟网络编辑器"></a>查看虚拟网络编辑器</h2><p><img src="https://img-blog.csdnimg.cn/20190531143321832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="修改IP（虚拟网络的IP）"><a href="#修改IP（虚拟网络的IP）" class="headerlink" title="修改IP（虚拟网络的IP）"></a>修改IP（虚拟网络的IP）</h2><p><img src="https://img-blog.csdnimg.cn/20190531143328972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="这里插入图片描述"></p><h2 id="查看网关"><a href="#查看网关" class="headerlink" title="查看网关"></a>查看网关</h2><p><img src="https://img-blog.csdnimg.cn/2019053114350952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="查看windows环境中的VMnet8网络配置"><a href="#查看windows环境中的VMnet8网络配置" class="headerlink" title="查看windows环境中的VMnet8网络配置"></a>查看windows环境中的VMnet8网络配置</h2><p>方式1：命令行输入：ipconfig</p><p>方式2：右键点击菜单栏网络图标——&gt;打开网络和共享中心——&gt;更改适配器——&gt;选择VMnet8——&gt;右键查看属性——&gt;选择IPv4</p><h1 id="ping-测试主机之间网络连通性"><a href="#ping-测试主机之间网络连通性" class="headerlink" title="ping 测试主机之间网络连通性"></a>ping 测试主机之间网络连通性</h1><p>基本语法：ping 目的主机 （功能描述：测试当前服务器是否可以连接目的主机）<br><strong>实例</strong><br>测试当前服务器是否可以连接百度 [root@hadoop100 桌面]# ping <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></p><p><img src="https://img-blog.csdnimg.cn/20190531143520945.png" alt="这里插入图片描述"></p><h1 id="Linux网络环境配置"><a href="#Linux网络环境配置" class="headerlink" title="Linux网络环境配置"></a>Linux网络环境配置</h1><h2 id="第一种方法-自动获取"><a href="#第一种方法-自动获取" class="headerlink" title="第一种方法(自动获取)"></a>第一种方法(自动获取)</h2><p>说明：登陆后，通过界面的来设置自动获取ip</p><p><img src="https://img-blog.csdnimg.cn/20190531143529736.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>特点：linux启动后会自动获取IP,缺点是每次自动获取的ip地址可能不一样。，不适用于做服务器，因为我们的服务器的IP需要是固定的</strong></p><h2 id="第二种方法-指定固定的ip"><a href="#第二种方法-指定固定的ip" class="headerlink" title="第二种方法(指定固定的ip)"></a>第二种方法(指定固定的ip)</h2><p>说明 直接修改配置文件来指定IP,并可以连接到外网(程序员推荐)，</p><p>编辑 vim  /etc/sysconfig/network-scripts/ifcfg-eth0 （etho的配置文件，如果多块需要配置多块的配置文件）</p><p><strong>实例</strong></p><p>要求：将ip地址配置的静态的，ip地址为192.168.168.130</p><p><strong>注意：设置的IP地址如果和虚拟机的VMnet网卡的IP网段需要是一样的，如果不一样就无法建立通信，本例子中的IP设置和前面图的IP不在同一网段</strong></p><p>1)步骤1，修改网卡配置文件</p><p><img src="https://img-blog.csdnimg.cn/20190531143537436.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="这里插入图片描述"></p><p>2）步骤2 ，重新启动网络服务</p><p><img src="https://img-blog.csdnimg.cn/20190531143544501.png" alt="在这里插入图片描述"></p><h2 id="ifcfg-eth0文件说明"><a href="#ifcfg-eth0文件说明" class="headerlink" title="ifcfg-eth0文件说明"></a>ifcfg-eth0文件说明</h2><p><img src="https://img-blog.csdnimg.cn/20190531143551261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>、</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;虚拟机网络模式&quot;&gt;&lt;a href=&quot;#虚拟机网络模式&quot; class=&quot;headerlink&quot; title=&quot;虚拟机网络模式&quot;&gt;&lt;/a&gt;虚拟机网络模式&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux实操" scheme="http://yoursite.com/tags/Linux%E5%AE%9E%E6%93%8D/"/>
    
  </entry>
  
  <entry>
    <title>Linux实操篇-磁盘分区和挂载</title>
    <link href="http://yoursite.com/2019/05/31/Linux%E5%AE%9E%E6%93%8D%E7%AF%87-%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E5%92%8C%E6%8C%82%E8%BD%BD/"/>
    <id>http://yoursite.com/2019/05/31/Linux实操篇-磁盘分区和挂载/</id>
    <published>2019-05-31T04:19:44.595Z</published>
    <updated>2019-07-23T13:47:28.757Z</updated>
    
    <content type="html"><![CDATA[<p><meta name="referrer" content="no-referrer"></p><h1 id="分区基本知识"><a href="#分区基本知识" class="headerlink" title="分区基本知识"></a>分区基本知识</h1><h2 id="分区的方式："><a href="#分区的方式：" class="headerlink" title="分区的方式："></a>分区的方式：</h2><p><strong>1) mbr分区:</strong> </p><p>1.最多支持四个主分区 </p><p>2.系统只能安装在主分区 </p><p>3.扩展分区要占一个主分区 </p><p>4.MBR最大只支持2TB，但拥有最好的兼容性<br><strong>2) gtp分区:</strong> </p><p>1.支持无限多个主分区（但操作系统可能限制，比如 windows下最多128个分区） </p><p>2.最大支持18EB的大容量（1EB=1024 PB，1PB=1024 TB ）</p><p> 3.windows7 64位以后支持gtp</p><h2 id="windows下的磁盘分区"><a href="#windows下的磁盘分区" class="headerlink" title="windows下的磁盘分区"></a>windows下的磁盘分区</h2><p><img src="https://img-blog.csdnimg.cn/20190531131558967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="Linux分区"><a href="#Linux分区" class="headerlink" title="Linux分区"></a>Linux分区</h1><h2 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h2><p> 1) Linux来说无论有几个分区，分给哪一目录使用，它归根结底就只有一个根目录，一个独 立且唯一的文件结构 , Linux中每个分区都是用来组成整个文件系统的一部分。<br>2) Linux采用了一种叫“载入”的处理方法，它的整个文件系统中包含了一整套的文件和目 录，且将一个分区和一个目录联系起来。这时要载入的一个分区将使它的存储空间在一 个目录下获得。 </p><p>3) 示意图<img src="https://img-blog.csdnimg.cn/2019053113161697.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="硬盘说明"><a href="#硬盘说明" class="headerlink" title="硬盘说明"></a>硬盘说明</h2><p>1) Linux硬盘分IDE硬盘和SCSI硬盘，目前基本上是SCSI硬盘</p><p>2) 对于IDE硬盘，驱动器标识符为“hdx~”,其中“hd”表明分区所在设备的类型，这里是指 IDE硬盘了。“x”为盘号（a为基本盘，b为基本从属盘，c为辅助主盘，d为辅助从属 盘）,“~”代表分区，前四个分区用数字1到4表示，它们是主分区或扩展分区，从5开始就 是逻辑分区。例，hda3表示为第一个IDE硬盘上的第三个主分区或扩展分区,hdb2表示为 第二个IDE硬盘上的第二个主分区或扩展分区。</p><p>3) 对于SCSI硬盘则标识为“sdx~”，SCSI硬盘是用“sd”来表示分区所在设备的类型的，其余 则和IDE硬盘的表示方法一样。</p><h2 id="查看所有设备挂载情况"><a href="#查看所有设备挂载情况" class="headerlink" title="查看所有设备挂载情况"></a>查看所有设备挂载情况</h2><p>命令 ：lsblk （谐音：老师不离开） 或者 lsblk -f<img src="https://img-blog.csdnimg.cn/20190531131629957.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20190531131640464.png" alt="在这里插入图片描述"></p><h1 id="挂载经典案例"><a href="#挂载经典案例" class="headerlink" title="挂载经典案例"></a>挂载经典案例</h1><h2 id="虚拟机增加硬盘"><a href="#虚拟机增加硬盘" class="headerlink" title="虚拟机增加硬盘"></a>虚拟机增加硬盘</h2><p>需求：为Linux系统新增加一块硬盘并将其挂载到Linux中的/home/newdisk目录下</p><h3 id="如何增加一块硬盘？"><a href="#如何增加一块硬盘？" class="headerlink" title="如何增加一块硬盘？"></a>如何增加一块硬盘？</h3><p>1）虚拟机添加硬盘</p><p>2）分区</p><p>3）格式化</p><p>4）挂载</p><p>5）设置可以自动挂载</p><h3 id="实操步骤："><a href="#实操步骤：" class="headerlink" title="实操步骤："></a>实操步骤：</h3><p>1）在【虚拟机】菜单中，选择【设 置】，然后设备列表里添加硬盘， 然后一路【下一步】，中间只有 选择磁盘大小的地方需要修改， 至到完成。然后重启系统（才能 识别）！</p><p><img src="https://img-blog.csdnimg.cn/2019053113165895.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>2）分区命令 fdisk   /dev/sdb </p><p>开始对/sdb分区</p><p> • m   显示命令列表</p><p> • p    显示磁盘分区 同 fdisk  –l </p><p>• n    新增分区 • d     删除分区 </p><p>• w   写入并退出</p><p> 说明： 开始分区后输入n，新增分区，然后选择p ，分区类型为主分区。两次回车默认剩 余全部空间。最后输入w写入分区并退出，若不保存退出输入q。</p><p><img src="https://img-blog.csdnimg.cn/20190531131708395.png" alt="在这里插入图片描述"></p><p>3）格式化分区</p><p>分区命令:mkfs -t  ext4   /dev/sdb1  其中ext4是分区类型</p><p>4）新建挂载目录，并将硬盘挂载到目录</p><p>挂载: 将一个分区与一个目录联系起来，</p><p> 基本语法：mount    设备名称 挂载目录</p><p> 例如： mount    /dev/sdb1    /newdisk</p><p>卸载： umount 设备名称 或者 挂载目录</p><p>  例如： umount /dev/sdb1 或者 umount /newdisk</p><p><strong>注意：</strong>用命令行挂载重启后会失效</p><p>5）设置可以自动挂载（永久挂载，当你重启系统，仍然可以挂载到/home/newdisk目录下）</p><p>永久挂载: 通过修改/etc/fstab实现挂载 添加完成后 执行mount   –a 即刻生效</p><p><img src="https://img-blog.csdnimg.cn/20190531131719985.png" alt="在这里插入图片描述"></p><h1 id="硬盘查询实用指令"><a href="#硬盘查询实用指令" class="headerlink" title="硬盘查询实用指令"></a>硬盘查询实用指令</h1><h2 id="查询系统整体磁盘使用情况"><a href="#查询系统整体磁盘使用情况" class="headerlink" title="查询系统整体磁盘使用情况"></a>查询系统整体磁盘使用情况</h2><p>基本语法： df -h </p><p><strong>实例</strong> </p><p>（1）查询系统整体磁盘使用情况</p><p><img src="https://img-blog.csdnimg.cn/20190531131729304.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="查询指定目录的磁盘占用情况"><a href="#查询指定目录的磁盘占用情况" class="headerlink" title="查询指定目录的磁盘占用情况"></a>查询指定目录的磁盘占用情况</h2><p>基本语法： du -h  /目录<br>查询指定目录的磁盘占用情况，默认为当前目录 </p><p>-s 指定目录占用大小汇总</p><p> -h 带计量单位 </p><p>-a 含文件</p><p> –max-depth=1  子目录深度 </p><p>-c 列出明细的同时，增加汇总值 </p><p><strong>实例</strong></p><p>（1） 查询 /opt 目录的磁盘占用情况，深度为1</p><p><img src="https://img-blog.csdnimg.cn/20190531131737331.png" alt="在这里插入图片描述"></p><h1 id="磁盘情况-工作中的实用指令"><a href="#磁盘情况-工作中的实用指令" class="headerlink" title="磁盘情况-工作中的实用指令"></a>磁盘情况-工作中的实用指令</h1><p>1) 统计/home文件夹下文件的个数</p><p><img src="https://img-blog.csdnimg.cn/20190531131802402.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p> 2) 统计/home文件夹下目录的个数 </p><p><img src="https://img-blog.csdnimg.cn/20190531131821252.png" alt="在这里插入图片描述"></p><p>3) 统计/home文件夹下文件的个数，包括子文件夹里的</p><p><img src="https://img-blog.csdnimg.cn/20190531131904948.png" alt="在这里插入图片描述"></p><p>4) 统计文件夹下目录的个数，包括子文件夹里的</p><p><img src="https://img-blog.csdnimg.cn/20190531131914503.png" alt="在这里插入图片描述"></p><p> 5) 以树状显示目录结构</p><p><img src="https://img-blog.csdnimg.cn/20190531131926211.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;分区基本知识&quot;&gt;&lt;a href=&quot;#分区基本知识&quot; class=&quot;headerlink&quot; title=&quot;分区基本知识&quot;&gt;&lt;/a&gt;分区基本知识&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux实操" scheme="http://yoursite.com/tags/Linux%E5%AE%9E%E6%93%8D/"/>
    
  </entry>
  
  <entry>
    <title>Linux实操篇-定时调度任务与实例</title>
    <link href="http://yoursite.com/2019/05/30/Linux%E5%AE%9E%E6%93%8D%E7%AF%87-%E5%AE%9A%E6%97%B6%E8%B0%83%E5%BA%A6%E4%BB%BB%E5%8A%A1/"/>
    <id>http://yoursite.com/2019/05/30/Linux实操篇-定时调度任务/</id>
    <published>2019-05-30T05:58:36.568Z</published>
    <updated>2019-07-21T10:56:07.368Z</updated>
    
    <content type="html"><![CDATA[<p><meta name="referrer" content="no-referrer"></p><h1 id="crond任务调度"><a href="#crond任务调度" class="headerlink" title="crond任务调度"></a>crond任务调度</h1><h2 id="crontab-进行定时任务的设置"><a href="#crontab-进行定时任务的设置" class="headerlink" title="crontab 进行定时任务的设置"></a>crontab 进行定时任务的设置</h2><p> 任务调度：是指系统在某个时间执行的特定的命令或程序。</p><p>原理示意图:</p><p><img src="https://img-blog.csdnimg.cn/20190530171313863.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20190530171308189.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p> 任务调度分类：</p><p>​     1）系统工作：有些重要的工作必须周而复始地执行。如病毒扫描等</p><p>​      2）个别用户工作：个别用户可能希望执行某些程序，比如对mysql数据库的备份。 </p><p>基本语法 ：crontab [选项] </p><p>常用选项</p><table><thead><tr><th style="text-align:left">选项</th><th style="text-align:center">选项说明</th></tr></thead><tbody><tr><td style="text-align:left">-e</td><td style="text-align:center">编辑crontab定时任务</td></tr><tr><td style="text-align:left">-l</td><td style="text-align:center">查询crontab任务</td></tr><tr><td style="text-align:left">-r</td><td style="text-align:center">删除当前用户所有的crontab任务</td></tr></tbody></table><h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><h2 id="任务要求"><a href="#任务要求" class="headerlink" title="任务要求"></a>任务要求</h2><p>1)设置任务调度文件：/etc/crontab </p><p>2)设置个人任务调度。执行crontab –e命令。</p><p>3) 接着输入任务到调度文件 如：<em>/1 </em>  <em>  </em>  *  ls –l  /etc/ &gt; /tmp/to.txt  </p><p>4)意思说每小时的每分钟执行ls –l /etc/ &gt; /tmp/to.txt命令 </p><h2 id="步骤如下"><a href="#步骤如下" class="headerlink" title="步骤如下"></a>步骤如下</h2><p>1）cron -e</p><p>2)输入：<em>/1 </em> <em> </em> * ls -l /etc &gt;&gt;/tmp/to.txt</p><p>3）保存退出后就完成</p><p>4)在每一分钟都会自动的调用 ls-l/etc &gt;&gt;/tmp/to.txt</p><h2 id="参数细节说明"><a href="#参数细节说明" class="headerlink" title="参数细节说明"></a>参数细节说明</h2><p>5个占位符的说明</p><table><thead><tr><th>项目</th><th>含义</th><th>范围</th></tr></thead><tbody><tr><td>第一个“*”</td><td>一小时当中的第几分钟</td><td>0-59</td></tr><tr><td>第二个“*”</td><td>一天当中的第几小时</td><td>0-23</td></tr><tr><td>第三个“*”</td><td>一个月当中的第几天</td><td>1-31</td></tr><tr><td>第五个“*”</td><td>一周当中的星期几</td><td>0-7（0和7都代表星期日）</td></tr><tr><td>特殊符号的说明</td><td></td></tr></tbody></table><table><thead><tr><th style="text-align:left">特殊符号</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">*</td><td style="text-align:left">代表任何时间。比如第一个“*”就代表一小时中每分钟都执行一 次的意思。</td></tr><tr><td style="text-align:left">，</td><td style="text-align:left">代表不连续的时间。比如“0 8,12,16 <em> </em> * 命令”，就代表在每天 的8点0分，12点0分，16点0分都执行一次命令</td></tr><tr><td style="text-align:left">-</td><td style="text-align:left">代表连续的时间范围。比如“0 5 <em> </em> 1-6命令”，代表在周一到周 六的凌晨5点0分执行命令</td></tr><tr><td style="text-align:left">*/n</td><td style="text-align:left">代表每隔多久执行一次。比如“<em>/10 </em> <em> </em> * 命令”，代表每隔 10分钟就执行一遍命令</td></tr></tbody></table><p>特定时间执行任务案例</p><table><thead><tr><th style="text-align:left">时间</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:left">45 22 <em>  </em>  * 命令</td><td style="text-align:center">在22点45分执行命令</td></tr><tr><td style="text-align:left">0 17 <em> </em> 1 命令</td><td style="text-align:center">每周1 的17点0分执行命令</td></tr><tr><td style="text-align:left">0 5 1,15 <em> </em> 命令</td><td style="text-align:center">每月1号和15号的凌晨5点0分执行命令</td></tr><tr><td style="text-align:left">40 4 <em> </em> 1-5 命令</td><td style="text-align:center">每周一到周五的凌晨4点40分执行命令</td></tr><tr><td style="text-align:left"><em>/10 4 </em> <em> </em> 命令</td><td style="text-align:center">每天的凌晨4点，每隔10分钟执行一次命令</td></tr><tr><td style="text-align:left">0 0 1,15 * 1 命令</td><td style="text-align:center">每月1号和15号，每周1的0点0分都会执行命令。</td></tr></tbody></table><p>注意：星期几和 几号最好不要同时出现，因为他们定义的都是天。非常容易让管理员混乱。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;crond任务调度&quot;&gt;&lt;a href=&quot;#crond任务调度&quot; class=&quot;headerlink&quot; title=&quot;crond任务调度&quot;&gt;&lt;/a&gt;crond任务
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux实操" scheme="http://yoursite.com/tags/Linux%E5%AE%9E%E6%93%8D/"/>
    
  </entry>
  
  <entry>
    <title>Linux实操篇-组管理和权限管理</title>
    <link href="http://yoursite.com/2019/05/29/Linux%E5%AE%9E%E6%93%8D%E7%AF%87-%E7%BB%84%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2019/05/29/Linux实操篇-组管理/</id>
    <published>2019-05-29T02:06:34.892Z</published>
    <updated>2019-07-21T10:56:33.784Z</updated>
    
    <content type="html"><![CDATA[<p><meta name="referrer" content="no-referrer"></p><h1 id="Linux组基本介绍"><a href="#Linux组基本介绍" class="headerlink" title="Linux组基本介绍"></a>Linux组基本介绍</h1><p>在linux中的每个用户必须属于一个组，不能独立于组外。在linux中每个文件 有所有者、所在组、其它组的概念。<br>1) 所有者 </p><p>2) 所在组 </p><p>3) 其它组</p><p> 4) 改变用户所在的组</p><p><img src="https://img-blog.csdnimg.cn/20190529173048969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="文件-目录-所有者"><a href="#文件-目录-所有者" class="headerlink" title="文件/目录 所有者"></a>文件/目录 所有者</h1><p>概念：一般为文件的创建者，谁创建了文件，就自然的成为该文件的所有者。</p><h2 id="查看文件的所有者"><a href="#查看文件的所有者" class="headerlink" title="查看文件的所有者"></a>查看文件的所有者</h2><p>1) 指令：ls –ahl</p><p> <strong>实例</strong></p><p>（1）创建一个组police，再创建一个用户tom，将tom放在police组中，然后使用tom来创建一个文件ok.txt，并查看文件所有者</p><p>步骤1：创建police组以及tom用户并将tom放在police组中</p><p><img src="https://img-blog.csdnimg.cn/20190529173212243.png" alt="在这里插入图片描述"></p><p>步骤2：使用tom用户创建ok.txt文件</p><p><img src="https://img-blog.csdnimg.cn/20190529173222543.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>特别说明：文件的所在组一般是所有者的所在组，但是也是可以更改的</p><h1 id="文件-目录所在组"><a href="#文件-目录所在组" class="headerlink" title="文件/目录所在组"></a>文件/目录所在组</h1><h2 id="修改文件所有者"><a href="#修改文件所有者" class="headerlink" title="修改文件所有者"></a>修改文件所有者</h2><p>指令：</p><p>1）chown  newowner  file  改变文件的所有者<br>2）chown newowner:newgroup  file  改变用户的所有者和所有组 </p><p>3）-R   如果是目录 则使其下所有子文件或目录递归生效</p><p><strong>实例</strong></p><p>（1）使用root创建一个文件apple.txt，然后将其修改为tom </p><p><img src="https://img-blog.csdnimg.cn/20190529173237218.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>（2) 请将 /home/kkk 目录下所有的文件和目录的所有者都修改成tom </p><p>   首先我们应该选择root用户操作</p><p><img src="https://img-blog.csdnimg.cn/2019052917330094.png" alt="在这里插入图片描述"></p><h2 id="组的创建"><a href="#组的创建" class="headerlink" title="组的创建"></a>组的创建</h2><p>基本指令: groupadd 组名<br>实例</p><p>(1) 创建一个组, ,monster 创建一个用户 fox ，并放入到 monster组中</p><p><img src="https://img-blog.csdnimg.cn/20190529173320299.png" alt="在这里插入图片描述"></p><h2 id="修改文件所在的组"><a href="#修改文件所在的组" class="headerlink" title="修改文件所在的组"></a>修改文件所在的组</h2><p>  基本指令 ：</p><p>1）chgrp 组名 文件名 </p><p>2）-R   如果是目录 则使其下所有子文件或目录递归生效</p><p><strong>实例</strong> </p><p>（1）使用root用户创建文件 orange.txt ,看看当前这个文件属于哪个组，然后将这个文 件所在组，修改到 police组。</p><p><img src="https://img-blog.csdnimg.cn/20190529173328558.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>（2） 请将 /home/kkk 目录下所有的文件和目录的所在组都修改成 police</p><p>  chgrp -R police  /home/kkk/</p><h2 id="其它组"><a href="#其它组" class="headerlink" title="其它组"></a>其它组</h2><p>介绍：除文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组。</p><h2 id="改变用户所在组"><a href="#改变用户所在组" class="headerlink" title="改变用户所在组"></a>改变用户所在组</h2><p>在添加用户时，可以指定将该用户添加到哪个组中，同样的用root的管理权限可以改变某 个用户所在的组。 改变用户所在组</p><p> 1) usermod   –g   组名 用户名</p><p> 2) usermod   –d   目录名 用户名 改变该用户登陆的初始目录。</p><p><strong>实例</strong></p><p>（1）创建一个土匪组（bandit）将tom这个用户从原来所在的police组，修改为</p><p>土匪组（bandit）</p><p><img src="https://img-blog.csdnimg.cn/20190529173345959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="权限的基本介绍"><a href="#权限的基本介绍" class="headerlink" title="权限的基本介绍"></a>权限的基本介绍</h1><p>ls  -l 中显示的内容如下： -rwxrw-r– 1 root root 1213 Feb 2 09:39 abc<br><strong>0-9位说明</strong> </p><p>1) 第0位确定文件类型(d, - , l , c , b)</p><p> 2) 第1-3位确定所有者（该文件的所有者）拥有该文件的权限。—User </p><p>3) 第4-6位确定所属组（同用户组的）拥有该文件的权限，—Group</p><p> 4) 第7-9位确定其他用户拥有该文件的权限 —Other</p><p><img src="https://img-blog.csdnimg.cn/20190529173358872.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="rwx权限详解"><a href="#rwx权限详解" class="headerlink" title="rwx权限详解"></a>rwx权限详解</h1><h2 id="rwx作用到文件"><a href="#rwx作用到文件" class="headerlink" title="rwx作用到文件"></a>rwx作用到文件</h2><p> 1) [ r ]代表可读(read): 可以读取,查看 </p><p>2) [ w ]代表可写(write): 可以修改,但是不代表可以删除该文件,删除一个文件的前提条件是 对该文件所在的目录有写权限，才能删除该文件.</p><p>3) [ x ]代表可执行(execute):可以被执行</p><h2 id="rwx作用到目录"><a href="#rwx作用到目录" class="headerlink" title="rwx作用到目录"></a>rwx作用到目录</h2><p>1) [ r ]代表可读(read): 可以读取，ls查看目录内容 </p><p>2) [ w ]代表可写(write): 可以修改,目录内创建+删除+重命名目录</p><p> 3) [ x ]代表可执行(execute):可以进入该目录</p><h1 id="文件及目录权限实际案例"><a href="#文件及目录权限实际案例" class="headerlink" title="文件及目录权限实际案例"></a>文件及目录权限实际案例</h1><p><strong>ls  -l 中显示的内容如下：</strong></p><p> -rwxrw-r– 1 root root 1213 Feb 2 09:39 abc </p><p>10个字符确定不同用户能对文件干什么</p><p> 第一个字符代表文件类型：文件 (-),目录(d),链接(l) </p><p>其余字符每3个一组(rwx) 读(r) 写(w) 执行(x)</p><p> 第一组rwx : 文件拥有者的权限是读、写和执行 </p><p>第二组rw-: 与文件拥有者同一组的用户的权限是读、写但不能执行</p><p> 第三组r– : 不与文件拥有者同组的其他用户的权限是读不能写和执行 </p><p><strong>可用数字表示为:</strong> r=4,w=2,x=1 因此rwx=4+2+1=7      </p><table><thead><tr><th>权限</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td>1</td><td style="text-align:center">文件：硬连接数或 目录：子目录数</td></tr><tr><td>root</td><td style="text-align:center">用户</td></tr><tr><td>root</td><td style="text-align:center">组</td></tr><tr><td>1213</td><td style="text-align:center">文件大小（字节），如果是文件夹，显示4096字节</td></tr><tr><td>Feb 2 09:39</td><td style="text-align:center">最后修改日期</td></tr><tr><td>abc</td><td style="text-align:center">文件名</td></tr></tbody></table><h1 id="修改权限-chmod"><a href="#修改权限-chmod" class="headerlink" title="修改权限-chmod"></a>修改权限-chmod</h1><p>基本说明： 通过chmod指令，可以修改文件或者目录的权限。</p><h2 id="第一种方式"><a href="#第一种方式" class="headerlink" title="第一种方式"></a>第一种方式</h2><p>第一种方式：+ 、-、= 变更权限 u:所有者 g:所在组 o:其他人 a:所有人(u、g、o的总和)</p><p>1) chmod   u=rwx,g=rx,o=x   文件目录名 </p><p>功能描述：u=rwx给所有者rwx权限，g=rx给所在组的其他用户提供rx权限，o=x其他组用户提供x权限</p><p>2) chmod   o+w    文件目录名 </p><p>功能描述：给其他组用户添加提供w(写)权限</p><p>3) chmod   a-x    文件目录名</p><p>功能描述：给所用用户减去x(执行)权限</p><p><img src="https://img-blog.csdnimg.cn/20190529173502574.png" alt="在这里插入图片描述"></p><p> <strong>实例</strong></p><p>1) 给abc文件 的所有者读写执行的权限，给所在组读执行权限，给其它组读执行权限。</p><p><img src="https://img-blog.csdnimg.cn/20190529173516275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>特别说明：文件获取可执行权限之后，文件名字变成绿色</p><p>2) 给abc文件的所有者除去执行的权限，增加组写的权限 </p><p><img src="https://img-blog.csdnimg.cn/20190529173532152.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>3) 给abc文件的所有用户添加读的权限</p><p><img src="https://img-blog.csdnimg.cn/20190529173549105.png" alt="在这里插入图片描述"></p><h2 id="第二种方式"><a href="#第二种方式" class="headerlink" title="第二种方式"></a>第二种方式</h2><p>第二种方式：通过数字变更权限 </p><p>r=4 w=2 x=1        rwx=4+2+1=7</p><p> chmod u=rwx,g=rx,o=x    文件目录名 </p><p>相当于 chmod   751  文件目录名</p><p> <strong>实例</strong></p><p> （1）将 /home/abc.txt 文件的权限修改成 rwxr-xr-x, 使用给数字的方式实现：</p><p>rwx=4+2+1=7</p><p>r-x=4+1=5</p><p>r-x=5+1=5</p><p>指令：chmod 755 /home/abc.txt</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Linux组基本介绍&quot;&gt;&lt;a href=&quot;#Linux组基本介绍&quot; class=&quot;headerlink&quot; title=&quot;Linux组基本介绍&quot;&gt;&lt;/a&gt;Linu
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux实操" scheme="http://yoursite.com/tags/Linux%E5%AE%9E%E6%93%8D/"/>
    
  </entry>
  
  <entry>
    <title>Java基础篇-Java异常处理</title>
    <link href="http://yoursite.com/2019/05/25/Java%E5%9F%BA%E7%A1%80%E7%AF%87-Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2019/05/25/Java基础篇-Java异常处理/</id>
    <published>2019-05-25T09:49:40.996Z</published>
    <updated>2019-07-21T10:54:29.886Z</updated>
    
    <content type="html"><![CDATA[<p><meta name="referrer" content="no-referrer"></p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p><strong>介绍</strong></p><p>异常：就是程序在运行时出现不正常的情况</p><p>异常由来：问题也是现实生活中一个具体的事物，也可以通过java的类的形式进行描述。并封装成对象。其实就是java对不征程情况进行描述后的对象体现</p><p><strong>问题的划分</strong></p><p>1）严重的问题  2）非严重的问题</p><p><strong>问题的描述</strong></p><p>1）对于严重的问题，java通过使用Error类进行描述</p><p>​        对于Error一般不编写针对性的代码进行处理</p><p>2）对于非严重的问题，java通过Exception类进行描述</p><p>​        对于Exception可以使用针对性的处理方式进行处理</p><p><strong>说明</strong></p><p>无论是Error还是Exception都具有一些的共性内容</p><p>比如不正常的情况信息引发原因等,于是向上抽取形成Throwable体系</p><p>Throwable</p><p>​         |–Error</p><p>​         |–Exception</p><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><h2 id="java提供了以下特有的语句进行异常处理"><a href="#java提供了以下特有的语句进行异常处理" class="headerlink" title="java提供了以下特有的语句进行异常处理"></a><strong>java提供了以下特有的语句进行异常处理</strong></h2><p><img src="https://img-blog.csdnimg.cn/20190528135104306.png" alt="在这里插入图片描述"></p><p><strong>注意</strong>：如果在try中定义有变量，则这个变量只能在try语句范围内有效</p><p><strong>实例：</strong></p><p><img src="https://img-blog.csdnimg.cn/20190528135112945.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="对捕获异常对象进行的常见方法操作"><a href="#对捕获异常对象进行的常见方法操作" class="headerlink" title="对捕获异常对象进行的常见方法操作"></a>对捕获异常对象进行的常见方法操作</h1><p> 1） String   getMessage();//获取异常信息字符串      </p><p>​          说明：获取的只有异常信息，较为简单</p><p><img src="https://img-blog.csdnimg.cn/20190528135120763.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>2）String   toString()//获取异常名称 ：异常信息     </p><p>​     说明：获取的信息较为齐全</p><p>3）void prinStackTrace();//异常名称，异常信息，异常出现的位置</p><p>注意：jvm默认的异常处理机制就是在调用prinStackTrace方法。打印异常的堆栈跟踪信息</p><p>说明：信息最为齐全</p><h1 id="异常声明throws"><a href="#异常声明throws" class="headerlink" title="异常声明throws"></a>异常声明throws</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><strong>介绍</strong></h2><p>在程序的开发过程中，应该对可能出现异常并未处理的功能模块使用throws进行标识声明将，在调用者使用该功能模块时知道该模块可能出现问题，并进行异常处理，如果不处理将会出现编译失败的情况。</p><p><img src="https://img-blog.csdnimg.cn/20190528135137565.png" alt="在这里插入图片描述"></p><h2 id="处理实例"><a href="#处理实例" class="headerlink" title="处理实例"></a>处理实例</h2><p>对功能模块中声明的异常，主函数在使用的时候针对抛出的异常进行捕抓并做相对应的处理</p><p><img src="https://img-blog.csdnimg.cn/20190528135205944.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="多异常处理"><a href="#多异常处理" class="headerlink" title="多异常处理"></a>多异常处理</h1><p>1）在声明异常时，建议声明更加具体的异常。这样的处理更加的具体。</p><p>2）对声明的异常进行处理时一般使用更加具体的异常进行异常处理，提高正对性</p><p>3）提高异常处理的针对性可以在发生声明的具体异常意外出现的异常进行及时有效的处理</p><p>总结：当功能模块可能出现多个异常时一般使用多异常的处理机制进行处理</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>1）多异常声明方法：throws 异常1，异常2</p><p><img src="https://img-blog.csdnimg.cn/20190528135217661.png" alt="在这里插入图片描述"></p><p>2）异常处理方法，书写对应的catch语句对捕获异常进行处理,如图所示</p><p><img src="https://img-blog.csdnimg.cn/20190528135224521.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>​     1）对方声明几个异常就有几个catch块进行异常处理，不要定义多余的catch块</p><p>​     2）如果多个catch块中的异常出现继承关系，父类异常catch块放在最下面</p><p>​     3）建立catch处理时，catch中一定要定义具体处理方式，不要简单的定义一句                         e.printStackTrace(),也不要简单的书写一条输出语句。</p><p>​      4）正确的处理异常方式是将异常结果输出记录到异常记录文件，提供维护人员进行维护</p><h1 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p>Java针对了普遍有可能出现的问题进行了总结和封装成类的形式，但是在项目开发的过程中同样会出现异常，这些异常部分可能是项目的特有异常Java中是没有定义的，所以就需要开发人员自定义异常。</p><h2 id="自定义异常类"><a href="#自定义异常类" class="headerlink" title="自定义异常类"></a>自定义异常类</h2><p>1）将异常封装成一个类并继承Exception,注意必须是自定义类继承Exception</p><p>原因：异常体系有一个特点：因为异常类和异常对象都被抛出他们都具备可抛性，这个可抛性是Throwable这个体系中独有特点，只有这个体系的类和对象才可以被throws和throw操作</p><p>2）添加异常信息，直接定义构造函数接收异常信息并调用父类方法即可添加</p><p><img src="https://img-blog.csdnimg.cn/20190528135235948.png" alt="在这里插入图片描述"></p><p>原因：在父类的Throwable中已经定义了错误信息接收机制，子类直接使用父类构造方法即可</p><p><img src="https://img-blog.csdnimg.cn/20190528135241669.png" alt="在这里插入图片描述"></p><h2 id="自定义异常方法"><a href="#自定义异常方法" class="headerlink" title="自定义异常方法"></a>自定义异常方法</h2><p>1）定义一个自定义的异常类</p><p>2)在功能模块中，达到了异常条件时将自定义异常手动抛出</p><p>3）对抛出异常对象进行处理，处理方式</p><p>（1）在函数内部使用try catch处理，如下图所示</p><p><img src="https://img-blog.csdnimg.cn/20190528135316758.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>（2）在函数上声明让调用者进行处理</p><p>注意：</p><p>（1）由于自定义异常非Java本身定义所以在编写功能模块时需要使用关键字throw将异常手动抛出</p><p>（1）编写功能模块时，功能模块内部引起的异常则在内部进行处理，如果是外部调用者导致的功能异常则将异常抛出由调用者解决（即谁直接导致或操作导致异常的发生谁就对该异常进行处理，不能层层抛出去）</p><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p>需求：在进行除法运算时，对于除数是负数的情况，也视为是错误的无法进行运算的</p><p>（1）自定义异常类</p><p><img src="https://img-blog.csdnimg.cn/201905281356033.png" alt="在这里插入图片描述"></p><p>（2）功能模块</p><p><img src="https://img-blog.csdnimg.cn/20190528135530957.png" alt="在这里插入图片描述"></p><p>（3）调用者函数</p><p><img src="https://img-blog.csdnimg.cn/20190528135258949.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="throw和throws的区别"><a href="#throw和throws的区别" class="headerlink" title="throw和throws的区别"></a>throw和throws的区别</h2><p>1）throws使用在函数上</p><p>2）throw使用在函数内</p><p>3）throws后面跟的异常类，可以跟多个。用逗号隔开</p><p>4）throw后跟的是异常对象(不仅限于自定义异常)</p><h1 id="RuntimeException"><a href="#RuntimeException" class="headerlink" title="RuntimeException"></a>RuntimeException</h1><h2 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h2><p>对于异常分为两种：</p><p>1）编译时被检测异常</p><p>2）编译时不被检测异常（运行时异常。RuntimeException以及其子类）</p><p>RuntimeException是Exception中的特殊异常类</p><p> 该异常类特点：</p><p>（1）在函数内部throw异常对象时，不需要在函数上声明,编译一样通过</p><p>（2）在函数上进行声明，调用者<strong>可以</strong>不进行处理，编译一样通过</p><p>原因：之所以不用在函数上进行声明是因为不需要调用者进行处理，当该异常发生时希望程序停止。因为在运行时，出现了无法继续运算的情况，希望停止程序后对代码进行修正</p><h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><p><img src="https://img-blog.csdnimg.cn/20190528135306703.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="自定义异常新类型"><a href="#自定义异常新类型" class="headerlink" title="自定义异常新类型"></a>自定义异常新类型</h2><p>自定义异常时：如果该异常的发生，无法继续进行运算，就让自定义异常继承RuntimeException</p><h1 id="异常-finally"><a href="#异常-finally" class="headerlink" title="异常-finally"></a>异常-finally</h1><p>介绍：finally代码块存放着程序中一定会执行的代码</p><p>常用环境：常用于关闭资源</p><p>注意：finally只有一种情况不执行，当执行到System.exit(0),finally不会执行</p><h1 id="异常-覆盖时的异常特点"><a href="#异常-覆盖时的异常特点" class="headerlink" title="异常-覆盖时的异常特点"></a>异常-覆盖时的异常特点</h1><p>1）子类在覆盖父类方法时，如果覆盖的父类方法抛出异常，那么子类的覆盖方法只能抛出父类的异常或该异常的子类或者不抛出异常</p><p>2）如果在覆盖方法的时候出现了新的异常，这种情况不可以将异常抛出，而是将异常处理在函数内部</p><p>3）如果父类方法抛出多异常，那么子类在覆盖该方法时，只能抛出父类异常的子集</p><p>4）如果父类或者接口方法中没有异常抛出，那么子类在覆盖方法时，也不可以抛出异常，如果子类发生了异常就只能进行try处理，绝对不能抛出</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>异常的好处</p><p>1)将问题进行封装</p><p>2）将正常流程代码和问题处理代码相分离，方便阅读</p><p>异常处理原则</p><p>1）处理方式有两种:try或者throws</p><p>2）调用到抛出异常的功能时，抛出几个就处理几个（一个try，对应多个catch）</p><p>3）多个catch，父类的catch放到最下面</p><p>4）catch内，需要定义针对性的处理方式。不要简单定义printStackTrace输出语句,也不要不写，当捕获的异常本功能处理不了时，可以在catch中抛出</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;介绍&lt;/strong
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Linux实操篇-Linux实用指令</title>
    <link href="http://yoursite.com/2019/05/25/Linux%E5%AE%9E%E6%93%8D%E7%AF%87-Linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2019/05/25/Linux实操篇-Linux实用指令/</id>
    <published>2019-05-25T05:04:48.707Z</published>
    <updated>2019-07-21T10:55:34.794Z</updated>
    
    <content type="html"><![CDATA[<p><meta name="referrer" content="no-referrer"></p><h1 id="运行级别指令"><a href="#运行级别指令" class="headerlink" title="运行级别指令"></a>运行级别指令</h1><h2 id="运行级别说明"><a href="#运行级别说明" class="headerlink" title="运行级别说明"></a>运行级别说明</h2><p>Linux有七个运行级别，如下所示</p><table><thead><tr><th>运行级别</th><th style="text-align:center">级别说明</th></tr></thead><tbody><tr><td>0</td><td style="text-align:center">关机</td></tr><tr><td>1</td><td style="text-align:center">单用户（找回丢失密码）</td></tr><tr><td>2</td><td style="text-align:center">多用户无网络服务</td></tr><tr><td>3</td><td style="text-align:center">多用户有网络服务（用的最多的）</td></tr><tr><td>4</td><td style="text-align:center">保留尚未使用</td></tr><tr><td>5</td><td style="text-align:center">图形界面</td></tr><tr><td>6</td><td style="text-align:center">重启（启用该运行别之后机器进入该级别就会重启）</td></tr></tbody></table><p><strong>运行级别配置文件：/etc/inittab</strong></p><p>常用的运行级别是3和5，要修改默认的运行级别可以修改运行级别配置文件：/etc/inittab的id:5 initdefault:这行中的数字</p><h2 id="指定运行级别"><a href="#指定运行级别" class="headerlink" title="指定运行级别"></a>指定运行级别</h2><p>基本语法： init [0123456]</p><p>举例：从图像界面到运行级别3，再从级别3回退到级别5</p><p>在Linux的图形界面中，打开终端输入：init  3 回车进入级别3，再输入init5即可回到级别5</p><h2 id="【面试题】如何找回root密码"><a href="#【面试题】如何找回root密码" class="headerlink" title="【面试题】如何找回root密码"></a>【面试题】如何找回root密码</h2><p>题目：如何找回root密码，如果我们不小心忘记了root密码，怎么找回？</p><p>思路：进入到单用户模式（运行级别1），然后修改root密码，因为进入单用户模式，root不需要密码就可以登录</p><p>实际操作步骤：<br>1）启动系统没有进入到登录页面前点击enter键暂停启动，如下图所示</p><p><img src="https://img-blog.csdnimg.cn/20190528131532841.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="img"></p><p>2）输入e,编辑命令在启动之前，进入如下页面</p><p><img src="https://img-blog.csdnimg.cn/2019052813175089.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="img"></p><p>3)将光标移动到第二行，再输入e(编辑内核)，进入如下页面，输入1（运行级别1，单用户模式）</p><p><img src="https://img-blog.csdnimg.cn/20190528131906868.png" alt="在这里插入图片描述"></p><p>4）输入enter键，再输入b，开始引导</p><p>5）开始进入单用户模式，用户登录为root</p><p><img src="https://img-blog.csdnimg.cn/20190528132000508.png" alt="在这里插入图片描述"></p><p>6）进入之后直接输入passwd root进行修改root账户密码。</p><p>7）输入reboot重启完成操作</p><p><strong>细节说明</strong></p><p>1）不允许通过使用远程操作的方式进行修改密码，需要进行直接操作电脑的方式进行</p><p>2）假如默认运行级别被修改为级别0，出现无法开机的情况，解决办法是进入单用户模式修改默认启动级别即可</p><h1 id="帮助指令"><a href="#帮助指令" class="headerlink" title="帮助指令"></a>帮助指令</h1><p>当我们对某个指令不熟悉时，我们可以使用Linux指令的帮助指令进行了解指令的使用方法。</p><h2 id="man-获得帮助信息"><a href="#man-获得帮助信息" class="headerlink" title="man 获得帮助信息"></a>man 获得帮助信息</h2><p> 基本语法 :man [命令或配置文件]（功能描述：获得帮助信息） </p><h2 id="help指令"><a href="#help指令" class="headerlink" title="help指令"></a>help指令</h2><p> 基本语法:help 命令 （功能描述：获得shell内置命令的帮助信息） </p><p>百度帮助更直接</p><p>虽然上面两个都可以来获取指令帮助，但是需要英语功底，如果英语不太好的，我还是 推荐大家直接百度靠谱。</p><h1 id="文件目录类"><a href="#文件目录类" class="headerlink" title="文件目录类"></a>文件目录类</h1><h2 id="pwd-指令"><a href="#pwd-指令" class="headerlink" title="pwd 指令"></a>pwd 指令</h2><p>功能描述：显示当前工作目录的绝对路径</p><p>基本语法：pwd</p><h2 id="ls指令"><a href="#ls指令" class="headerlink" title="ls指令"></a>ls指令</h2><p> 基本语法：ls [选项] [目录或是文件] </p><p> 常用选项</p><p>1） -a ：显示当前目录所有的文件和目录，包括隐藏的。</p><p>2） -l  ：以列表的方式显示信息 </p><p> 操作实例如图所示：</p><p><img src="https://img-blog.csdnimg.cn/20190528132021365.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20190528132031802.png" alt="在这里插入图片描述"></p><h2 id="cd-指令"><a href="#cd-指令" class="headerlink" title="cd 指令"></a>cd 指令</h2><p>功能描述：进入到指定目录</p><p> 基本语法 ：cd  [参数] (功能描述：切换到指定目录)</p><p> 常用参数 ：</p><p>1） 绝对路径和相对路径 </p><p>2）cd ~ 或者cd 回到自己的家目录</p><p>3） cd .. 回到当前目录的上一级目录</p><h2 id="如何理解绝对绝对路径与相对路径："><a href="#如何理解绝对绝对路径与相对路径：" class="headerlink" title="如何理解绝对绝对路径与相对路径："></a>如何理解绝对绝对路径与相对路径：</h2><p>需求：从当前工作目录时的 /root进入到/home</p><p>绝对路径： /home，即从根目录开始定位</p><p>相对路径：../home，从当前工作目录定位</p><h2 id="mkdir指令"><a href="#mkdir指令" class="headerlink" title="mkdir指令"></a>mkdir指令</h2><p>功能描述：mkdir指令用于创建目录</p><p>基本语法：  mkdir  [选项] 要创建的目录 </p><p>常用选项 ：-p ：创建多级目录</p><p><strong>实例</strong></p><p>1）创建一个目录：/home/dog</p><p>指令： mkdir   /home/dog</p><p>2）创建多级目录 /home/animal/tiger</p><p>指令：mkdir -p  /home/animal/tiger</p><h2 id="rmdir指令"><a href="#rmdir指令" class="headerlink" title="rmdir指令"></a>rmdir指令</h2><p>功能描述： rmdir指令删除空目录</p><p> 基本语法     rmdir  [选项] 要删除的空目录 </p><p><strong>细节说明</strong> </p><p>1）rmdir 删除的是空目录，如果目录下有内容时无法删除的。</p><p>2）如果需要删除非空目录，需要使用指令： rm -rf 要删除的目录</p><h2 id="touch指令"><a href="#touch指令" class="headerlink" title="touch指令"></a>touch指令</h2><p>功能描述： touch指令创建空文件 </p><p> 基本语法     touch 文件名称 </p><p><strong>实例：</strong></p><p>1）创建一个文件: touch 1.txt</p><p>2)   创建多个文件：touch 1.txt   2.txt</p><h2 id="cp指令"><a href="#cp指令" class="headerlink" title="cp指令"></a>cp指令</h2><p>cp 指令拷贝文件到指定目录 </p><p>基本语法 cp [选项] source dest</p><p>常用选项 -r ：递归复制整个文件夹</p><p>说明： 强制覆盖不提示的方法：\cp</p><p><strong>实例：</strong></p><p>1）将当前目录下的1.txt文件拷贝到当前目录home/b目录下</p><p><img src="https://img-blog.csdnimg.cn/2019052813213189.png" alt="在这里插入图片描述"></p><p>2） 拷贝文件夹  ： cp  -r   源目录/   目标目录/</p><p>3）拷贝文件夹时，覆盖目标文件夹文件：\cp   -r   源目录/   目标目录/</p><h2 id="rm指令"><a href="#rm指令" class="headerlink" title="rm指令"></a>rm指令</h2><p>功能描述：rm 指令移除文件或目录 </p><p>基本语法 rm  [选项] 要删除的文件或目录</p><p> 常用选项         </p><p>1) -r ：递归删除整个文件夹</p><p>2）-f ： 强制删除不提示</p><p>说明：强制删除不提示的方法：带上 -f 参数即可</p><p><strong>实例</strong></p><p>（1）删除文件</p><p><img src="https://img-blog.csdnimg.cn/20190528132233147.png" alt="在这里插入图片描述"></p><p>（2）强制删除整个目录</p><p><img src="https://img-blog.csdnimg.cn/20190528132248421.png" alt="在这里插入图片描述"></p><h2 id="mv指令"><a href="#mv指令" class="headerlink" title="mv指令"></a>mv指令</h2><p>功能描述：mv 移动文件到相应目录或重命名 </p><p>基本语法</p><p>1）mv  oldNameFile newNameFile     (功能描述：重命名) </p><p>2）mv /temp/movefile /targetFolder (功能描述：移动文件)</p><p><strong>实例</strong></p><p>（1）重命名文件</p><p>需求：将当前目录下的aaa.txt文件重命名为pig.txt</p><p><img src="https://img-blog.csdnimg.cn/20190528132324523.png" alt="在这里插入图片描述"></p><p>细节说明：它的实质还是移动命令（即剪切），将当前目录下的aaa.txt文件，移动到当前目录下的pig.txt文件</p><p>（2）移动文件</p><p>需求：将当前目录下的pig.txt文件移动到/root目录下</p><p><img src="https://img-blog.csdnimg.cn/20190528132332540.png" alt="在这里插入图片描述"></p><h2 id="cat指令"><a href="#cat指令" class="headerlink" title="cat指令"></a>cat指令</h2><p>功能描述：cat 查看文件内容 ，以只读的方式</p><p>基本语法 ：cat  [选项] 要查看的文件 </p><p>常用选项 ：    -n ：显示行号</p><p><strong>实例</strong></p><p>需求：  读取/ect/profile 文件内容，并显示行号 </p><p><img src="https://img-blog.csdnimg.cn/20190528132348759.png" alt="在这里插入图片描述"></p><p><strong>细节说明</strong></p><p>1）它的功能只能查看文件内容，不能对文件进行修改。（只读的方式）</p><p>2）在使用cat命令为了浏览方便，一般会带上 管道命令 | more ，对文件分页显示，点击空格键即可浏览下一页。语法：cat  文件名 | more</p><h2 id="more指令"><a href="#more指令" class="headerlink" title="more指令"></a>more指令</h2><p>功能描述： more指令是一个基于VI编辑器的文本过滤器，它以全屏幕的方式按页          显示文本文件的内容。 more指令中内置了若干快捷键，详见操作说明</p><p>操作说明</p><table><thead><tr><th>操作</th><th style="text-align:center">功能说明</th></tr></thead><tbody><tr><td>空白键（space）</td><td style="text-align:center">代表向下翻一页</td></tr><tr><td>Enter</td><td style="text-align:center">代表向下翻一行</td></tr><tr><td>q</td><td style="text-align:center">代表立刻离开more ，不再显示该文件内容。</td></tr><tr><td>Ctrl+F</td><td style="text-align:center">向下滚动一屏</td></tr><tr><td>Ctrl+B</td><td style="text-align:center">返回上一屏</td></tr><tr><td>=</td><td style="text-align:center">输出当前行的行号</td></tr><tr><td>:f</td><td style="text-align:center">输出文件名和当前行的行号</td></tr></tbody></table><p>基本语法 ：more 要查看的文件 </p><h2 id="less指令"><a href="#less指令" class="headerlink" title="less指令"></a>less指令</h2><p>功能描述：less指令用来分屏查看文件内容，它的功能与more指令类似，但是比more指令更加强大，支 持各种显示终端。less指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是 根据显示需要加载内容，<strong>对于显示大型文件具有较高的效率。</strong></p><p>操作说明</p><table><thead><tr><th>操作</th><th style="text-align:center">功能说明</th></tr></thead><tbody><tr><td>空白键</td><td style="text-align:center">向下翻动一页</td></tr><tr><td>[pagedown]</td><td style="text-align:center">向下翻动一页</td></tr><tr><td>[pageup]</td><td style="text-align:center">向上翻动一页；</td></tr><tr><td>/字串</td><td style="text-align:center">向下搜寻『字串』的功能；n：向下查找；N：向上查找；</td></tr><tr><td>?字串</td><td style="text-align:center">向上搜寻『字串』的功能；n：向上查找；N：向下查找；</td></tr><tr><td>q</td><td style="text-align:center">离开 less 这个程序；</td></tr></tbody></table><h2 id="指令-gt-和-gt-gt-指令"><a href="#指令-gt-和-gt-gt-指令" class="headerlink" title="指令&gt; 和 &gt;&gt; 指令"></a><strong>指令&gt; 和 &gt;&gt; 指令</strong></h2><p>输出重定向&gt;和 &gt;&gt; 追加 </p><p>功能描述：</p><p>1)输出重定向&gt;添加内到指定文件会将原来的文件内容覆盖</p><p>2）追加&gt;&gt;添加内容到指定文件不会覆盖原来的文件内容，而是追加到文件末尾</p><p>基本语法<br>1) ls -l &gt;文件 （功能描述：列表的内容写入文件a.txt中（覆盖写））<br>2) ls -al &gt;&gt;文件 （功能描述：列表的内容追加到文件aa.txt的末尾）<br>3)  cat 文件1 &gt; 文件2 （功能描述：将文件1的内容覆盖到文件2）<br>4) echo “内容”&gt;&gt; 文件 (功能描述：直接将双引号中的内容追加到指定文件中)</p><p><strong>实例</strong></p><p>（1）需求：创建a.txt文件并存入当前列表信息</p><p><img src="https://img-blog.csdnimg.cn/20190528132418567.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>说明：ls-l &gt;a.txt,是将ls-l的显示内容覆盖写入到a.txt文件中。如果该文件不存在，将新建一个a.txt文件</p><p>（2）将文件1的内容覆盖到文件2<img src="https://img-blog.csdnimg.cn/20190528132429912.png" alt="在这里插入图片描述"></p><h2 id="echo指令"><a href="#echo指令" class="headerlink" title="echo指令"></a>echo指令</h2><p>功能描述： echo输出内容到控制台。 </p><p>基本语法 echo  [选项] [输出内容]</p><p>实例</p><p>（1）输出环境变量路径（path）</p><p><img src="https://img-blog.csdnimg.cn/20190528132429912.png" alt="在这里插入图片描述"></p><p>(2)输出hello到控制台</p><p><img src="https://img-blog.csdnimg.cn/20190528132516600.png" alt="在这里插入图片描述"></p><h2 id="head指令"><a href="#head指令" class="headerlink" title="head指令"></a>head指令</h2><p>功能描述：head用于显示文件的开头部分内容，默认情况下head指令显示文件的前10行内容 </p><p>基本语法：</p><p>1） head 文件 (功能描述：查看文件头10行内容) </p><p>2）head -n 5 文件 (功能描述：查看文件头5行内容，5可以是任意行数) </p><p><strong>实例</strong></p><p>（1）查看/etc/profile文件前五行</p><p><img src="https://img-blog.csdnimg.cn/20190528132530553.png" alt="在这里插入图片描述"></p><h2 id="tail指令"><a href="#tail指令" class="headerlink" title="tail指令"></a>tail指令</h2><p>功能描述：tail用于输出文件中尾部的内容，默认情况下tail指令显示文件的前10行内容。 </p><p>基本语法 </p><p>1) tail  文件 （功能描述：查看文件后10行内容） </p><p>2) tail  -n 5 文件 （功能描述：查看文件后5行内容，5可以是任意行数） </p><p>3) tail  -f  文件 （功能描述：实时追踪该文档的所有更新） </p><p><strong>实例</strong></p><p>（1）查看/etc/profile 最后5行的代码</p><p><img src="https://img-blog.csdnimg.cn/20190528132542862.png" alt="在这里插入图片描述"></p><p>（2）实时监控mydate.txt,看看文件有变化时，是否看到实时的追加日期</p><p>​      1）tail  -f  文件对文件进行实时监控</p><p><img src="https://img-blog.csdnimg.cn/20190528132548946.png" alt="在这里插入图片描述"></p><p>​       2）在其他终端向文件添加内容，实时监控终端也会同步更新显示</p><h2 id="ln-指令"><a href="#ln-指令" class="headerlink" title="ln 指令"></a>ln 指令</h2><p>功能描述：软链接也成为符号链接，类似于windows里的快捷方式，主要存放了链接其他文件的路径</p><p> 基本语法： ln -s [原文件或目录] [软链接名] （功能描述：给原文件创建一个软链接）</p><p> 细节说明：当我们使用pwd指令查看目录时，仍然看到的是软链接所在目录。</p><p> <strong>实例</strong> </p><p>（1） 在/home 目录下创建一个软链接 linkToRoot，连接到 /root 目录<br><img src="https://img-blog.csdnimg.cn/20190528132605835.png" alt="在这里插入图片描述"></p><p>（2） 删除软连接 linkToRoot（删除软链接的时候不要带斜杠，否则提示忙）</p><p><img src="https://img-blog.csdnimg.cn/20190528132619958.png" alt="在这里插入图片描述"></p><h2 id="history指令"><a href="#history指令" class="headerlink" title="history指令"></a>history指令</h2><p>查看已经执行过历史命令,也可以执行历史指令</p><p> 基本语法 ：history （功能描述：查看已经执行过历史命令） </p><p><strong>实例</strong></p><p>（1）显示所有的历史命令 </p><p>  <img src="https://img-blog.csdnimg.cn/20190528132637679.png" alt="在这里插入图片描述"></p><p>（2） 显示最近使用过的10个指令</p><p><img src="https://img-blog.csdnimg.cn/20190528132648240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>（3）执行历史编号为178的指令</p><p><img src="https://img-blog.csdnimg.cn/20190528132656910.png" alt="在这里插入图片描述"></p><h1 id="时间日期类"><a href="#时间日期类" class="headerlink" title="时间日期类"></a>时间日期类</h1><h2 id="date指令-显示当前日期"><a href="#date指令-显示当前日期" class="headerlink" title="date指令-显示当前日期"></a>date指令-显示当前日期</h2><p>基本语法 </p><p>1) date （功能描述：显示当前时间）</p><p> 2) date +%Y （功能描述：显示当前年份）</p><p> 3) date +%m （功能描述：显示当前月份）</p><p> 4) date +%d （功能描述：显示当前是哪一天） </p><p>5) date “+%Y-%m-%d %H:%M:%S”（功能描述：显示年月日时分秒）</p><p><strong>实例</strong></p><p>（1）显示当前年月日</p><p>​               1）第一种方式</p><p><img src="https://img-blog.csdnimg.cn/20190528132711318.png" alt="在这里插入图片描述"></p><p>​                2）第二种方式</p><p><img src="https://img-blog.csdnimg.cn/2019052813272178.png" alt="在这里插入图片描述"></p><h2 id="date指令-设置日期"><a href="#date指令-设置日期" class="headerlink" title="date指令-设置日期"></a>date指令-设置日期</h2><p>基本语法： date  -s 字符串时间 </p><p><strong>实例</strong></p><p> （1） 设置系统当前时间 ， 比如设置成 2018-10-10 11:22:22</p><p><img src="https://img-blog.csdnimg.cn/20190528132731337.png" alt="在这里插入图片描述"></p><h2 id="cal指令"><a href="#cal指令" class="headerlink" title="cal指令"></a>cal指令</h2><p>功能描述：查看日历指令 </p><p>基本语法： cal [选项] （功能描述：不加选项，显示本月日历） </p><p>实例 </p><p>（1） 显示当前日历</p><p><img src="https://img-blog.csdnimg.cn/20190528132745857.png" alt="在这里插入图片描述"></p><p> （2） 显示2020年日历</p><p><img src="https://img-blog.csdnimg.cn/20190528132752412.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="搜索查找类"><a href="#搜索查找类" class="headerlink" title="搜索查找类"></a>搜索查找类</h1><h2 id="find指令"><a href="#find指令" class="headerlink" title="find指令"></a>find指令</h2><p>功能描述： find指令将从指定目录向下递归地遍历其各个子目录，将满足条件的文件或者目录显示在终 端。</p><p> 基本语法 ：find  [搜索范围] [选项]</p><p>常用选项说明</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-name&lt;查询方式&gt;</td><td>按照指定的文件名查找模式查找文件</td></tr><tr><td>-user&lt;用户名&gt;</td><td>-user&lt;用户名&gt;</td></tr><tr><td>-size&lt;文件大小&gt;</td><td>按照指定的文件大小查找文件。</td></tr></tbody></table><p><strong>实例</strong></p><p>（1） 按文件名：根据名称查找/home 目录下的hello.txt文件 </p><p><img src="https://img-blog.csdnimg.cn/20190528132803531.png" alt="在这里插入图片描述"></p><p>（2）按拥有者：查找/opt目录下，用户名称为 nobody的文件</p><p><img src="https://img-blog.csdnimg.cn/20190528132813335.png" alt="在这里插入图片描述"></p><h2 id="locate指令"><a href="#locate指令" class="headerlink" title="locate指令"></a>locate指令</h2><p>功能描述： locaate指令可以快速定位文件路径。locate指令利用事先建立的系统中所有文件名称及路径 的locate数据库实现快速定位给定的文件。Locate指令无需遍历整个文件系统，查询速度较快。 为了保证查询结果的准确度，管理员必须定期更新locate时刻。 </p><p>基本语法 ：locate 搜索文件</p><p> 特别说明： 由于locate指令基于数据库进行查询，所以第一次运行前，必须使用updatedb指令创建locate 数据库。</p><p> <strong>实例</strong> </p><p>（1）请使用locate 指令快速定位 hello.txt 文件所在目录</p><p><img src="https://img-blog.csdnimg.cn/20190528132845187.png" alt="在这里插入图片描述"></p><h2 id="grep指令和-管道符号"><a href="#grep指令和-管道符号" class="headerlink" title="grep指令和 管道符号 |"></a>grep指令和 管道符号 |</h2><p>功能描述： grep 过滤查找 ， 管道符，“|”，表示将前一个命令的处理结果输出传递给后面的命令处理。<br>基本语法 ：grep [选项] 查找内容 源文件</p><p> 常用选项</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-n</td><td>显示匹配行以及行号</td></tr><tr><td>-i</td><td>忽略字母大小写</td></tr></tbody></table><p>实例</p><p> （1） 请在 hello.txt 文件中，查找 “yes”  所在行(区分大小写)，并且显示行号</p><p><img src="https://img-blog.csdnimg.cn/20190528132857739.png" alt="在这里插入图片描述"></p><p> （1） 请在 hello.txt 文件中，查找 “yes”  或”Yes”所在行，并且显示行号</p><p><img src="https://img-blog.csdnimg.cn/20190528132910240.png" alt="在这里插入图片描述"></p><h1 id="压缩和解压类"><a href="#压缩和解压类" class="headerlink" title="压缩和解压类"></a>压缩和解压类</h1><h2 id="gzip-gunzip-指令"><a href="#gzip-gunzip-指令" class="headerlink" title="gzip/gunzip 指令"></a>gzip/gunzip 指令</h2><p>功能描述：gzip 用于压缩文件， gunzip 用于解压的<br>基本语法 ：</p><p>1）gzip 文件 （功能描述：压缩文件，只能将文件压缩为*.gz文件）</p><p>2）gunzip 文件.gz （功能描述：解压缩文件命令）<br><strong>实例</strong></p><p>（1）gzip压缩， 将 /home下的 hello.txt文件进行压缩 </p><p> <img src="https://img-blog.csdnimg.cn/20190528133108238.png" alt="在这里插入图片描述"></p><p>（2）gunzip压缩， 将 /home下的 hello.txt.gz 文件进行解压缩</p><p><img src="https://img-blog.csdnimg.cn/20190528133114193.png" alt="在这里插入图片描述"></p><h2 id="zip-unzip-指令"><a href="#zip-unzip-指令" class="headerlink" title="zip/unzip 指令"></a>zip/unzip 指令</h2><p>功能描述：zip 用于压缩文件， unzip 用于解压的，这个在项目打包发布中很有用的<br>基本语法：</p><p> zip      [选项] XXX.zip  将要压缩的内容（功能描述：压缩文件和目录的命令） unzip [选项] XXX.zip （功能描述：解压缩文件） </p><p> zip常用选项： -r：递归压缩，即压缩目录 </p><p>unzip的常用选项： -d&lt;目录&gt; ：指定解压后文件的存放目录 </p><p><strong>实例</strong> </p><p>（1） 将 /home下的 所有文件进行压缩成 mypackage.zip</p><p><img src="https://img-blog.csdnimg.cn/20190528133129470.png" alt="在这里插入图片描述"></p><p>（2） 将 mypackge.zip 解压到 /opt/tmp 目录下</p><p><img src="https://img-blog.csdnimg.cn/20190528133140104.png" alt="在这里插入图片描述"></p><h2 id="tar-指令"><a href="#tar-指令" class="headerlink" title="tar 指令"></a>tar 指令</h2><p>功能描述：tar 指令 是打包指令，最后打包后的文件是 .tar.gz 的文件。<br>基本语法：</p><p> tar  [选项]  XXX.tar.gz  打包的内容 (功能描述：打包目录，压缩后的文件格式.tar.gz)      </p><p> 选项说明（压缩带上前四个参数，如果是解压就不带z参数应带x参数）</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-c</td><td>产生.tar打包文件</td></tr><tr><td>-v</td><td>显示详细信息</td></tr><tr><td>-f</td><td>指定压缩后的文件名</td></tr><tr><td>-z</td><td>打包同时压缩</td></tr><tr><td>-x</td><td>解包.tar文件</td></tr></tbody></table><p><strong>实例</strong> </p><p>(1) 压缩多个文件，将 /home/a1.txt 和 /home/a2.txt 压缩成 a.tar.gz </p><p> <img src="https://img-blog.csdnimg.cn/20190528133148164.png" alt="在这里插入图片描述"></p><p>(2)  将/home 的文件夹 压缩成 myhome.tar.gz </p><p><img src="https://img-blog.csdnimg.cn/201905281331544.png" alt="在这里插入图片描述"></p><p>(3)  将 a.tar.gz  解压到当前目录(注意参数)</p><p><img src="https://img-blog.csdnimg.cn/20190528133200378.png" alt="在这里插入图片描述"></p><p>(4)将myhome.tar.gz 解压到 /opt目录下（指定解压的目录，事先需要存在，否则报错）</p><p><img src="https://img-blog.csdnimg.cn/20190528133207573.png" alt="在这里插入图片描述"></p><ul><li>gunzip压缩， 将 /home下的 hello.txt.gz 文件进行解压缩</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;运行级别指令&quot;&gt;&lt;a href=&quot;#运行级别指令&quot; class=&quot;headerlink&quot; title=&quot;运行级别指令&quot;&gt;&lt;/a&gt;运行级别指令&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux实操" scheme="http://yoursite.com/tags/Linux%E5%AE%9E%E6%93%8D/"/>
    
  </entry>
  
  <entry>
    <title>Linux实操篇-常见命令与用户管理</title>
    <link href="http://yoursite.com/2019/05/24/Linux%E5%AE%9E%E6%93%8D%E7%AF%87-%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4%E4%B8%8E%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2019/05/24/Linux实操篇-常见命令与用户管理/</id>
    <published>2019-05-24T10:46:55.166Z</published>
    <updated>2019-07-21T10:55:54.022Z</updated>
    
    <content type="html"><![CDATA[<p><meta name="referrer" content="no-referrer"></p><h1 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h1><h2 id="关机-amp-重启相关命令"><a href="#关机-amp-重启相关命令" class="headerlink" title="关机&amp;重启相关命令"></a>关机&amp;重启相关命令</h2><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>shutdown  -h    1</td><td>一分钟后关机</td></tr><tr><td>shutdown   -h   now</td><td>立即进行关机</td></tr><tr><td>shutdown   -r    now</td><td>立即重启计算机</td></tr><tr><td>halt</td><td>关机</td></tr><tr><td>reboot</td><td>现在重启计算机</td></tr><tr><td>sync</td><td>把内存的数据同步到磁盘</td></tr></tbody></table><p><strong>注意：</strong></p><p>不管是重启计算机还是关闭计算机，都需要运行sync命令，把内存中的数据写到磁盘中去，防止数据丢失。</p><h2 id="用户登录和注销"><a href="#用户登录和注销" class="headerlink" title="用户登录和注销"></a>用户登录和注销</h2><p>1) 登录时尽量少用root帐号登录，因为它是系统管理员，最大的权限，避免操作失误。可以使用普通用户登录，涉及到需要更高权限的操作时，在登录后再用”su - 用户名’命令来切换成系统管理员身份</p><p> 2) 在提示符下输入 logout 即可注销用户</p><p><strong>细节：</strong> logout 注销指令在图形运行级别无效，在 运行级别 3下有效</p><h1 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Linux系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先向 系统管理员申请一个账号，然后以这个账号的身份进入系统。</p><h2 id="用户管理常见指令"><a href="#用户管理常见指令" class="headerlink" title="用户管理常见指令"></a>用户管理常见指令</h2><p><strong>添加用户</strong></p><p>基本语法：命令行输入useradd  用户名</p><p>说明：</p><p>1) 当创建用户成功后，会自动的创建和用户同名的家目录 </p><p>2) 也可以通过 useradd -d  指定目录 新的用户名，给新创建的用户指定家目录</p><p><strong>指定/修改密码</strong></p><p>基本语法： passwd    用户名 </p><p><strong>删除用户</strong></p><p>基本语法 </p><p>1）删除用户，但是保留家目录：userdel   用户名</p><p>2）删除用户以及用户家目录： userdel -r  用户名</p><p>注意：在实际开发中如果出现开发人员离职的情况，需要删除用户，但是不会删除家目录因为在家目录中还有很多的工程源码。</p><p><strong>查询用户信息</strong></p><p>基本语法： id   用户名</p><p><img src="https://img-blog.csdnimg.cn/20190524201801183.png" alt="在这里插入图片描述"></p><p><strong>切换用户</strong></p><p>在操作Linux中，如果当前用户的权限不够，可以通过 su - 指令，切换到高权限用户，比如root 基本语法 su   切换用户名 </p><p> 细节说明</p><p> 1) 从权限高的用户切换到权限低的用户，不需要输入密码，反之需要。</p><p> 2) 当需要返回到原来用户时，使用exit指令</p><p>实例：创建一个用户zwj，然后切换到zwj</p><p><img src="https://img-blog.csdnimg.cn/20190524201815392.png" alt="在这里插入图片描述"></p><p><strong>查看当前登录用户</strong></p><p>基本语法：whoami/who am i</p><p>两种命令执行效果如下图所示</p><p><img src="https://img-blog.csdnimg.cn/20190524201829766.png" alt="在这里插入图片描述"></p><h2 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h2><p><strong>介绍</strong></p><p>类似于角色，系统可以对有共性的多个用户进行统一的管理，比如武侠小说中的门派，每一个用户都有一个属于自己的门派有自己独特的武功</p><p><strong>增加用户组</strong></p><p>基本语法：groupadd 组名</p><p>操作示意图</p><p><img src="https://img-blog.csdnimg.cn/20190524201839402.png" alt="在这里插入图片描述"></p><p><strong>删除用户组</strong></p><p>基本语法： groupdel 组名</p><p>操作示意图</p><p><img src="https://img-blog.csdnimg.cn/20190524201850716.png" alt="在这里插入图片描述"></p><p><strong>添加用户时候为用户指定对应的组</strong></p><p><img src="https://img-blog.csdnimg.cn/20190524201903669.png" alt="在这里插入图片描述"></p><p>细节说明：</p><p>1）前面的zwj账号已经被删除的基础上新建的zwj账号</p><p><strong>修改用户的组</strong></p><p>基本语法：user -g 用户组  用户名</p><p>细节说明：</p><p>1)用户组为用户修改到的新的用户组</p><h2 id="用户和组的相关文件"><a href="#用户和组的相关文件" class="headerlink" title="用户和组的相关文件"></a>用户和组的相关文件</h2><p><strong>/etc/passwd 文件</strong> </p><p>用户（user）的配置文件，记录用户的各种信息 </p><p>每行的含义：用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录</p><p><img src="https://img-blog.csdnimg.cn/20190524201913110.png" alt="在这里插入图片描述"></p><p><strong>Shell /etc/shadow 文件 </strong></p><p>口令的配置文件<br>每行的含义：登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警 告时间:不活动时间:失效时间:标志</p><p> <strong>/etc/group 文件</strong></p><p> 组(group)的配置文件，记录Linux包含的组的信息 </p><p>每行含义：组名:口令:组标识号:组内用户列表</p><p><img src="https://img-blog.csdnimg.cn/20190524201919499.png" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;常见命令&quot;&gt;&lt;a href=&quot;#常见命令&quot; class=&quot;headerlink&quot; title=&quot;常见命令&quot;&gt;&lt;/a&gt;常见命令&lt;/h1&gt;&lt;h2 id=&quot;关机-am
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux实操" scheme="http://yoursite.com/tags/Linux%E5%AE%9E%E6%93%8D/"/>
    
  </entry>
  
  <entry>
    <title>Linux基础篇-vi和vim编辑器</title>
    <link href="http://yoursite.com/2019/05/24/Linux%E5%9F%BA%E7%A1%80%E7%AF%87-vi%E5%92%8Cvim%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    <id>http://yoursite.com/2019/05/24/Linux基础篇-vi和vim编辑器/</id>
    <published>2019-05-24T08:39:22.229Z</published>
    <updated>2019-07-21T10:55:20.271Z</updated>
    
    <content type="html"><![CDATA[<p><meta name="referrer" content="no-referrer"></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>1）所有的Linux系统都会内建有vi文本编辑器</p><p>2）vim 具有程序编辑的能力，可以看做是Vi的增强版本，可以主动的以字体颜色辨别 语法的正确性，方便程序设计。代码补完、编译及错误跳转等方便编程的功能特别 丰富，在程序员中被广泛使用。</p><h1 id="vi和vim的常用三种模式"><a href="#vi和vim的常用三种模式" class="headerlink" title="vi和vim的常用三种模式"></a>vi和vim的常用三种模式</h1><p><strong>正常模式</strong>: </p><p>以 vim 打开一个档案就直接进入一般模式了(这是默认的模式)。在这个模式中， 你可以使用 『上下左右』按键来移动光标，你可以使用『删除字符』或『删除整行』来处理档案内容， 也可以使用『复制、贴上』来处理你的文件数据。 </p><p><strong>插入模式</strong>: </p><p>按下i, I, o, O, a, A, r, R等任何一个字母之后才会进入编辑模式, 一般来说按i即可.</p><p><strong>命令行模式</strong> ：</p><p>在这个模式当中， 可以提供你相关指令，完成读取、存盘、替换、离开 vim 、显示行号等的 动作则是在此模式中达成的！</p><h1 id="vi和vim的三种模式转换"><a href="#vi和vim的三种模式转换" class="headerlink" title="vi和vim的三种模式转换"></a>vi和vim的三种模式转换</h1><p><img src="https://img-blog.csdnimg.cn/20190524171350488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h1><p>需求：使用vim编辑器，开发一个Hello.java程序，并保存</p><p>步骤：</p><p>1）使用远程登录工具，登录服务器，这里使用Xshell进行连接</p><p>2）命令行键入vim Hello.java 新建Hello.java文件</p><p><img src="https://img-blog.csdnimg.cn/2019052417141042.png" alt="在这里插入图片描述"></p><p>3）当前属于正常模式，键盘输入i进入插入模式（命令行窗口底部提示进入插入模式）</p><p><img src="https://img-blog.csdnimg.cn/20190524171418602.png" alt="在这里插入图片描述"></p><p>4）直接使用键盘进行输入编辑文件内容，如图所示</p><p><img src="https://img-blog.csdnimg.cn/20190524171425487.png" alt="在这里插入图片描述"></p><p>5）保存并退出。首先由插入模式转换为正常模式，转换方式为按下键盘Esc键，转换到正常模式，正常模式输入：wq 保存并退出，这时候输入ll指令，就可以看到在目录里面已经存在Hello.java这个文件了</p><p><img src="https://img-blog.csdnimg.cn/20190524171439380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="常用vi和vim编辑器快捷键"><a href="#常用vi和vim编辑器快捷键" class="headerlink" title="常用vi和vim编辑器快捷键"></a>常用vi和vim编辑器快捷键</h1><p>1）删除当前行： dd,删除当前行向下的n行：ndd(n是删除行数)；模式：     正常模式</p><p>2）拷贝当前行：yy,拷贝当前行向下的n行：nyy(n是拷贝的行数)；粘贴指令：p;模式：正常模式</p><p>3) 在文件中查找某个单词 [命令行模式下 /关键字 ， 回车查找 ,  输入 n 就是查找下一个 ]<br>4) 设置文件的行号，取消文件的行号.[命令行下 : set nu 和 :set nonu] </p><p>5) 编辑 /etc/profile 文件，使用快捷键到底文档的最末行[G]和最首行[gg] </p><p>6) 在一个文件中输入 “hello” ,然后又撤销这个动作 u；模式：正常模式 </p><p>7) 将光标移动到 指定行，使用方式：行号+shift+g，模式：正常模式</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;1）所有的Linux系统都会内建有v
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux基础" scheme="http://yoursite.com/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Linux基础篇-Linux的远程登录与上传下载文件</title>
    <link href="http://yoursite.com/2019/05/23/Linux%E5%9F%BA%E7%A1%80%E7%AF%87-Linux%E7%9A%84%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E4%B8%8E%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2019/05/23/Linux基础篇-Linux的远程登录与上传下载文件/</id>
    <published>2019-05-23T14:30:07.769Z</published>
    <updated>2019-07-21T10:55:09.653Z</updated>
    
    <content type="html"><![CDATA[<p><meta name="referrer" content="no-referrer"></p><h1 id="Linux的远程登录"><a href="#Linux的远程登录" class="headerlink" title="Linux的远程登录"></a>Linux的远程登录</h1><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>在实际的使用的情况中，Linux的应用领域在服务器方面的运用比较多。由于服务器都是在远端的机房中，所以开发和维护人员无法通过直接操作服务器的方式展开工作。所以在实际的开发和维护中，开发和维护人员都通过使用远程登录的方式进行对服务器的操作。</p><h2 id="远程登录工具"><a href="#远程登录工具" class="headerlink" title="远程登录工具"></a>远程登录工具</h2><p>目前市面上的远程工具较多，本文介绍Xshell软件进行远程登录，理由如下：</p><p>1）相比SecureCRT，它是一款对个人是免费的软件，如果使用SecureCRT需要付费或者使用破解版；</p><p>2）配色与Linux一致，并且还改进了深蓝色字体不容易看见的问题</p><p>免费和界面的理由让我选择了它</p><p>注意：使用远程登录工具登录到服务器后是以命令行的方式显示显示在工具窗口中，程序员的工作环境也一般是命令行窗口</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>软件的安装过程较为简单，安装过程中选择家庭免费版进行安装即可。</p><p>1）第一步点击新建连接</p><p><img src="https://img-blog.csdnimg.cn/20190524152402295.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>2）设置连接信息，名称自定义即可，填写需要进行连接的服务器IP地址。最后点击确认按钮，新建连接成功。<br><img src="https://img-blog.csdnimg.cn/20190524152419611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>4）点击查看连接会话，查看新建的连接，点击连接服务器。若是第一次连接会提示输入登录账号密码，按要求输入即可</p><p><img src="https://img-blog.csdnimg.cn/20190524152434513.png" alt="在这里插入图片描述"></p><h1 id="Linux的远程上传下载文件"><a href="#Linux的远程上传下载文件" class="headerlink" title="Linux的远程上传下载文件"></a>Linux的远程上传下载文件</h1><p>1）Xshell的同系列软件还有Xftp它是远程上传下载文件的工具，同样的它也是免费的，它的创建和连接服务器的操作步骤与Xshell类似。需要注意的是在创建连接会话的时候应该将协议改为SFTP,端口切换为22号端口后连接。</p><p><img src="https://img-blog.csdnimg.cn/20190524152449488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>2）在连接成功后就会出现如下图所示的窗口，通过拖拽或者右键点击相应的文件再点击传输按钮即可实现文件的上传和下载功能。如下图所示</p><p><img src="https://img-blog.csdnimg.cn/20190524152505341.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>3）<strong>注意：如果出现中文乱码的问题，将编码方式设置成UTF-8即可，操作步骤如下：</strong></p><p><img src="https://img-blog.csdnimg.cn/20190524152517876.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Linux的远程登录&quot;&gt;&lt;a href=&quot;#Linux的远程登录&quot; class=&quot;headerlink&quot; title=&quot;Linux的远程登录&quot;&gt;&lt;/a&gt;Linu
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux基础" scheme="http://yoursite.com/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Linux基础篇-Linux的目录结构</title>
    <link href="http://yoursite.com/2019/05/22/Linux%E5%9F%BA%E7%A1%80%E7%AF%87-Linux%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2019/05/22/Linux基础篇-Linux的目录结构/</id>
    <published>2019-05-22T15:42:52.517Z</published>
    <updated>2019-07-21T10:55:01.239Z</updated>
    
    <content type="html"><![CDATA[<p><meta name="referrer" content="no-referrer"></p><h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><p>Linux的文件系统中采用的是级层式的树状目录结构，在目录的最上层是文件系统的根目录“/”，然后在此根目录下创建其他的目录。</p><p>一句经典的话：<strong>在Linux的世界里，一切皆文件</strong>（不管是软件还是硬件，都可以以文件的方式进行操作）</p><p>以下是文件系统树状图：</p><p><img src="https://img-blog.csdnimg.cn/20190523213856640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="img"></p><p>在CentOSE中的文件系统图像化目录如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20190523213910339.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjgzMDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="目录结构具体介绍"><a href="#目录结构具体介绍" class="headerlink" title="目录结构具体介绍"></a>目录结构具体介绍</h1><h2 id="文件系统的根目录"><a href="#文件系统的根目录" class="headerlink" title="文件系统的根目录"></a>文件系统的根目录</h2><p>在Linux中我们见到的都是树状结构，比如操作系统安装在了文件系统中，它是由”/“起始的树状结构，它就是Linux的最顶端，我们将其称之为Linux的root。Linux的文件系统入口就是“/”，所有的目录、文件、设备都在/之下，/就是Linux文件系统的组织者，也是最上级的领导者。</p><h2 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h2><p>概念：挂载的意思是将设备与系统的目录关联，实现对设备进行操作；</p><p>没有挂载的设备相当于一个封闭的盒子，里面的数据出不来外面的数据进不去，设备挂载之后，相当于给盒子开了一个窗户或者门，实现数据的交流。</p><h2 id="FHS规范"><a href="#FHS规范" class="headerlink" title="FHS规范"></a>FHS规范</h2><p>因为Linux属于开源的操作系统，所以在很多公司或者技术团队在使用过程中会对Linux的核心代码进行开发、编程等操作。这样的个性化开发将会目录存放数据混乱的问题。这个问题使Linux的开发人员无法对他人发的电脑进行开发和使用。于是FHS（Filesystem Hierarchy Standard ）标准诞生，解决了这个问题。规范目录下存放的数据内容，规范每一个特定目录下存放的数据。FHS依据文件系统使用的频繁与否与是否允许使用者进行随意改动，而将目录定义成为四种交互作用的形态，如下表所示：</p><table><thead><tr><th></th><th>可分享的(shareable)</th><th>不可分享的(unshareable)</th></tr></thead><tbody><tr><td>不变的(static)</td><td>/usr (软件放置处)</td><td>/etc (配置文件)</td></tr><tr><td></td><td>/opt (第三方协力软件)</td><td>/boot (开机与核心档)</td></tr><tr><td>可变动的(variable)</td><td>/var/mail (使用者邮件信箱)</td><td>/var/run (程序相关)</td></tr><tr><td></td><td>/var/spool/news (新闻组)</td><td>/var/lock (程序相关)</td></tr></tbody></table><p><strong>四种类型:</strong></p><p><strong>1.可分享的：</strong></p><p>可以分享给其他系统挂载使用的目录，所以包括执行文件与用户的邮件等数据， 是能够分享给网络上其他主机挂载用的目录；</p><p><strong>2.不可分享的：</strong></p><p>自己机器上面运作的装置文件或者是与程序有关的socket文件等， 仅与自身机器有关，不可以分享给其他主机。</p><p><strong>3.不变的：</strong></p><p>有些数据是不会经常变动的，跟随着distribution而不变动。 例如函式库、文件说明文件、系统管理员所管理的主机服务配置文件等等；</p><p><strong>4.可变动的：</strong></p><p>经常改变的数据，例如登录文件、一般用户可自行收受的新闻组等。</p><p>事实上，FHS针对目录树架构仅定义出三层目录底下应该放置什么数据而已，分别是底下这三个目录的定义：</p><p>/ (root, 根目录)：与开机系统有关；</p><p>/usr (unix software resource)：与软件安装/执行有关；</p><p>/var (variable)：与系统运作过程有关。</p><h2 id="根目录的意义"><a href="#根目录的意义" class="headerlink" title="根目录的意义"></a>根目录的意义</h2><p>根目录是操作系统的最重要的目录，其重要性等同于Windows系统中的c盘目录，它包含了各类的系统重要文件，由于根目录的重要性所以在FHS的标准中建议根目录所在分区越小越好，而且程序安装最好不要和根目录放在同一分区内，保持根分区越小越好，这样保证了文件系统出现问题的几率变小，同时使得文件系统的性能更佳。</p><p>基于以上的原因，FHS认为根目录下面应该包含以下的子目录：</p><table><thead><tr><th style="text-align:right">目录</th><th style="text-align:left">应放置文件内容</th></tr></thead><tbody><tr><td style="text-align:right">/bin</td><td style="text-align:left">是Binary的缩写，这个目录存放着最经常使用的命令。在/bin底下的指令可以被root与一般帐号所使用，主要有：cat,chmod(修改权限), chown, date, mv, mkdir, cp, bash等等常用的指令。</td></tr><tr><td style="text-align:right">/boot</td><td style="text-align:left">主要放置开机会使用到的核心文件，包括Linux连接文件、镜像文件</td></tr><tr><td style="text-align:right">/dev</td><td style="text-align:left">在Linux系统上，任何装置与周边设备都是以文件的型态存在于这个目录当中。 （相当于Windows的设备管理器，把所有的硬件用文件的形式存储）</td></tr><tr><td style="text-align:right">/etc</td><td style="text-align:left">所有的系统管理所需要的配置文件和子目录 my.conf。例如人员的帐号密码文件、各种服务的启始文件等等。 这个目录下的各文件属性是可以让一般使用者查阅的，但是只有root有权力修改。</td></tr><tr><td style="text-align:right">/home</td><td style="text-align:left">这是系统预设的使用者家目录(home directory)。 在你新增一个一般使用者帐号时，就会有一个与与户名相同的目录出现。比较重要的是，家目录有两种代号：~ ：代表当前使用者的家目录，而 ~guest：则代表用户名为guest的家目录。</td></tr><tr><td style="text-align:right">/lib</td><td style="text-align:left">系统开机所需要最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几 乎所有的应用程序都需要用到这些共享库。</td></tr><tr><td style="text-align:right">/media</td><td style="text-align:left">media是媒体的英文，顾名思义，这个/media底下放置的就是可移除的装置。 如：光碟、DVD、U盘等装置都暂时挂载于此。 常见的有：/media/floppy, /media/cdrom等等。</td></tr><tr><td style="text-align:right">/mnt</td><td style="text-align:left">系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂 载在/mnt/上，然后进入该目录就可以查看里的内容。 d:/myshare</td></tr><tr><td style="text-align:right">/opt</td><td style="text-align:left">这是给主机额外安装软件所摆放的目录。如安装ORACLE数据库就可放到该目录下。 默认为空。</td></tr></tbody></table><p><strong>事实上FHS针对根目录所定义的标准就仅限于上表，不过仍旧有些目录也需要我们了解一下，具体如下：</strong></p><table><thead><tr><th>目录</th><th style="text-align:left">应放置文件内容</th></tr></thead><tbody><tr><td>/proc</td><td style="text-align:left">这个目录本身是一个虚拟文件系统(virtual filesystem)。 它是系统内存的映射，访问这个目录来获取系统信息。</td></tr><tr><td>/lost+found</td><td style="text-align:left">这个目录是使用标准的ext2/ext3文件系统格式才会产生的一个目录，目的在于当档案系统发生错误时，将一些遗失的片段放置到这个目录下。（这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。）</td></tr><tr><td>/sys</td><td style="text-align:left">这是Linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统。</td></tr></tbody></table><p>除了这些目录的内容之外，另外要注意的是，因为根目录与开机有关，开机过程中仅有根目录会被挂载， 其他分区则是在开机完成之后才会持续的进行挂载的行为。就是因为如此，因此根目录下与开机过程有关的目录， 就不能够与根目录放到不同的分区去。</p><p>那哪些目录不可与根目录分开呢？有底下这些：</p><p><strong>/etc：</strong>各种软件与系统的设置文件，及软件的启动停止脚本 </p><p><strong>/bin：</strong>重要执行文件</p><p><strong>/dev：</strong>所需要的设置文件</p><p><strong>/lib：</strong>各种目标文件与函数库和各种不同版本内核的模块 </p><p><strong>/sbin：</strong>重要的系统执行文件</p><p>这五个目录千万不可与根目录分开在不同的分区。请背下来啊。</p><h2 id="usr-的意义与内容："><a href="#usr-的意义与内容：" class="headerlink" title="/usr 的意义与内容："></a>/usr 的意义与内容：</h2><p>　　/usr不是user的缩写，其实usr是Unix Software Resource的缩写， 也就是Unix操作系统软件资源所放置的目录。 FHS建议所有软件开发者，将他们的数据合理的放置到这个目录下的次目录，而不要自行建立该软件自己独立的目录。</p><p>　　因为是所有系统默认的软件(distribution发布者提供的软件)都会放置到/usr底下，因此这个目录有点类似Windows 系统的C:\Windows\ + C:\Program files\这两个目录的综合体，系统刚安装完毕时，这个目录会占用最多的硬盘容量。 一般来说，/usr的次目录建议有底下这些：</p><table><thead><tr><th>目录</th><th style="text-align:left">应放置的文件内容</th></tr></thead><tbody><tr><td>/usr/X11R6/</td><td style="text-align:left">为X Window System重要数据所放置的目录，之所以取名为X11R6是因为最后的X版本为第11版，且该版的第6次释出之意</td></tr><tr><td>/usr/bin/</td><td style="text-align:left">绝大部分的用户可使用指令都放在这里。所有可执行文件，如 gcc，firefox 等。请注意到他与/bin的不同之处。(是否与开机过程有关)</td></tr><tr><td>/usr/include/</td><td style="text-align:left">c/c++等程序语言的头文件(header)与包含文件(include)放置处，当我们以tarball方式 (*.tar.gz 的方式安装软件)安装某些数据时，会使用到里头的许多包含档。</td></tr><tr><td>/usr/lib/</td><td style="text-align:left">包含各应用软件的函式库、目标文件(object file)，以及不被一般使用者惯用的执行档或脚本(script)。 某些软件会提供一些特殊的指令来进行服务器的设定，这些指令也不会经常被系统管理员操作， 那就会被摆放到这个目录下啦。要注意的是，如果你使用的是X86_64的Linux系统， 那可能会有/usr/lib64/目录产生</td></tr><tr><td>/usr/local/</td><td style="text-align:left">这是另一个给主机额外安装软件所安装的目录。一般是通过编译源码方式安装的程序。举例：你的distribution提供的软件较旧，你想安装较新的软件但又不想移除旧版， 此时你可以将新版软件安装于/usr/local/目录下，可与原先的旧版软件有分别啦。 你可以自行到/usr/local去看看，该目录下也是具有bin, etc, include, lib…的次目录</td></tr><tr><td>/usr/sbin/</td><td style="text-align:left">非系统正常运作所需要的系统指令。最常见的就是某些网络服务器软件的服务指令(daemon)</td></tr><tr><td>/usr/share/</td><td style="text-align:left">放置共享文件的地方，在这个目录下放置的数据几乎是不分硬件架构均可读取的数据， 因为几乎都是文本文件嘛。在此目录下常见的还有这些次目录：/usr/share/man：联机帮助文件</td></tr><tr><td>/usr/src/</td><td style="text-align:left">一般原始码建议放置到这里，src有source的意思。至于核心原始码则建议放置到/usr/src/linux/目录下。</td></tr></tbody></table><h2 id="var-的意义与内容："><a href="#var-的意义与内容：" class="headerlink" title="/var 的意义与内容："></a>/var 的意义与内容：</h2><p>　　如果/usr是安装时会占用较大硬盘容量的目录，那么/var就是在系统运作后才会渐渐占用硬盘容量的目录。 因为/var目录主要针对常态性变动的文件，包括缓存(cache)、登录文件(log file)以及某些软件运作所产生的文件， 包括程序文件(lock file, run file)，或者例如MySQL数据库的文件等等。常见的次目录有：</p><table><thead><tr><th>目录</th><th style="text-align:left">应放置文件内容</th></tr></thead><tbody><tr><td>/var/cache/</td><td style="text-align:left">应用程序本身运作过程中会产生的一些暂存档</td></tr><tr><td>/var/lib/</td><td style="text-align:left">程序本身执行的过程中，需要使用到的数据文件放置的目录。在此目录下各自的软件应该要有各自的目录。 举例来说，MySQL的数据库放置到/var/lib/mysql/而rpm的数据库则放到/var/lib/rpm去</td></tr><tr><td>/var/lock/</td><td style="text-align:left">某些装置或者是文件资源一次只能被一个应用程序所使用，如果同时有两个程序使用该设备时， 就可能产生一些错误的状况，因此就得要将该装置上锁(lock)，以确保该设备只会给单一软件所使用。 举例来说，刻录机正在刻录一块光盘，如果两个人同时刻录，那片子写入的是谁的数据？所以当第一个人在刻录时该刻录机就会被上锁， 第二个人就得要该装置被解除锁定(就是前一个人用完了)才能够继续使用</td></tr><tr><td>/var/log/</td><td style="text-align:left">非常重要。这是登录文件放置的目录。里面比较重要的文件如/var/log/messages, /var/log/wtmp(记录登入者的信息)等。</td></tr><tr><td>/var/mail/</td><td style="text-align:left">放置个人电子邮件信箱的目录，不过这个目录也被放置到/var/spool/mail/目录中，通常这两个目录是互为链接文件。</td></tr><tr><td>/var/run/</td><td style="text-align:left">某些程序或者是服务启动后，会将他们的PID放置在这个目录下</td></tr><tr><td>/var/spool/</td><td style="text-align:left">这个目录通常放置一些队列数据，所谓的“队列”就是排队等待其他程序使用的数据。 这些数据被使用后通常都会被删除。举例来说，系统收到新信会放置到/var/spool/mail/中， 但使用者收下该信件后该封信原则上就会被删除。信件如果暂时寄不出去会被放到/var/spool/mqueue/中， 等到被送出后就被删除。如果是工作排程数据(crontab)，就会被放置到/var/spool/cron/目录中。</td></tr></tbody></table><p>由于FHS仅是定义出最上层(/)及次层(/usr, /var)的目录内容应该要放置的文件或目录数据， 因此，在其他次目录层级内，就可以随开发者自行来配置了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>1)Linux的目录中有且只有一个根目录/</p><p>2）Linux的各个目录存放的内容是规划好的，不可以乱放文件</p><p>3）Linux是以文件的方式进行管理设备，因此在Linux系统中，一切皆文件</p><p>4）学习要求：掌握目录存放内容、脑海中形成目录树</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h1&gt;&lt;p&gt;Linux的文件系统
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux基础" scheme="http://yoursite.com/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
